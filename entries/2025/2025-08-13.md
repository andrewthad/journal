# Refinements Without Refinements

One of the difficults when implementing refinements is that you end up with
two kinds of types. There are unrefined types, and there are refined types,
and they need different kinds. This has been a source of annoyance in every
proof of concept that I've done with refinement types.

Over time, I have decided to settle for less and less from refinements. I was
working on a system that didn't have refinements and then realized I needed
to add them so that I could scrutinize lists and get data from cons cells.
I realized that I already had subtyping available, and with it, it's possible
to create a hierarchy of types that can be used to accomplish the same purpose:

    List : * -> *
    Cons : * -> *
    Nil  : * -> *
    Nil  <: List
    Cons <: List
    nil  : forall (a : *). Nil a
    cons : forall (a : *). a -> List a -> Cons a

This is pretty cool. There are ways in which it is less powerful than
refinements. For a type with a larger number of data constructors, the user
needs to decide how they want to group them. You cannot just peel them off
one at a time in an arbitrary order. But I think this is ok. And there are
ways in which this approach is more expressive. It lets us have several
variants of a data type where fields are more refined. We are free to
upcast the more refined variant to a more permissive form at any time.

What about numbers? I think we could do this:

    Fin : Nat -> *
    Int : *
    Fin n <: Int

And we can still have helpful subtyping relationships like this:

    Fin n <: Fin (n + m)

We can do something similar as a refinement for bytes or characters. It will
be a little more tricky since it needs to be a universe of values instead
of an upper bound. But I think it should work.

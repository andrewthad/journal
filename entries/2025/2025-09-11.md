# Unboxed Sums vs Flexible Members

I had been thinking about defining a catenable builder like this:

    type Builder a
      | Builders (Array (Builder a))
      | Elements (Array a)
      | Empty // Technically, we don't need this.

If we want this to do a good job with spatial locality, we need the arrays
to be inlined. In C, this is called flexible array members. But I realized
that there is a more simple solution. Instead, we can just unbox `Builder`.
A builder becomes a 128-bit entity (instead of a 64-bit entity) when we do
this. An enormous advantage of this approach is that we can just turn any
existing array into a builder without allocating.

This is a competitive approach as long as every variant of the type is
small. It's works well for some implementations of tries and B trees.

# Type At Region

I've had an annoying problem with `List`. It ends up needing to have
a type like this: `List(a,r)@r`. This looks horrible, but it's easier
to implement this way.

# Adding Borrowing to Substructural Typing

I must have thought of this before, but I'm going to write down the idea before
I look back through old notes. Combining second-class values with a substructural
type system (either linearity or uniqueness) makes it possible to describe
borrowing. Here's how it works (example uses linear types):

    borrow : (a {2nd} -> b) -> a* {1st} -> (b, a* {1st})

The interpretation is, given a first-class value that must be linearly
consumed, we may borrow it as a second-class value that does not need
to be consumed linearly and use it freely in the callback. When the
callback returns, we recover the original value and the result (of type `b`).
It is not possible for the result to alias the argument to the callback.

# Previous Thought

I have an entry from 2024-05-06 where I explored this idea. In the same
entry, I spent a lot of time discussing how CPS interacts with linearity
and with second-class values.

There's a related entry from 2024-05-01. It has a good example near the end.
I lot of what this entry focuses on is the two differents arrow we have
and how to move between them. I spend more time focusing on linear types
because it seems better explored than uniqueness types. But uniqueness
types are probably more appropriate for what I am trying to do.

Let's go over this again, with linearity on binders. The plain function
arrow only has annotations on its arguments, not on the result types.
The fat arrow is syntactic sugar for CPS.

    a{m} => b{n}
    ===
    forall r. (b{n} -> r) -> a{m} -> r

Adapting the types of the Array operations from the Linear Haskell, we have:

    new    : (Int, a) => MutableArray a {1}
    write  : (MutableArray a {1}, Int, a) -> MutableArray a
    freeze : MutableArray a {1} => Array a

The type of `new` agrees with the paper. The freeze operation is a little
different though. Instead of using `Unrestricted` (and scrutiny) to prevent
an undesirable (and ill typed) expansion of a binder into a `freeze(mutArr)`
expression, we use a CPS function type. 

I would prefer to use the regular function arrow for freeze, but it is just
not the right type for this.

What about a `read` operation? I don't think that we need it. Instead, we
combine an `index` operation with borrowing:

    index  : (Array a [2nd], Int) -> a
    borrow : (Array a [2nd] -> b) {1} -> MutableArray a {1} -> (b, MutableArray a {1})

Borrow uses a second-class value in the callback to prevent it from being
returned as the result. With the appropriate syntactic sugar, we could
write this:

    dst0 <= new(100, True)
    dst1 <- write(dst0, 20, False)
    v10 <- index(&dst1, 10)
    v20 <- index(&dst1, 20)
    dst2 <- write(dst1, 10, False)
    () <= drop(dst2)
    pure(or(v10, v20))

This desugars to:

    dst0 <= new(100, True)
    dst1 <- write(dst0, 20, False)
    # Note: This hides the original dst1
    (v10, v20, dst1) <- borrow(dst1) fn(d : Array Bool):
      v10 <- index(d, 10)
      v20 <- index(d, 20)
      pure(v10, v20)
    dst2 <- write(dst1, 10, False)
    () <= drop(dst2)
    pure(or(v10, v20))

Any result of a function with a CPS function type must be bound to an
identifier. These cannot be used directly as function arguments. If
they could be used as function arguments, CSE would be unsound.

I like this formulation of borrowing because it makes the data dependencies
clear. Anything that uses `v10` or `v20` forces the evaluation of the
entire block. Similarly, the write to `dst1` forces `v10` and `v20` to
be computed.

It's possible to extend the second-class type system with an infinite
number of levels. This could be useful if we needed to borrow inside
of another borrow, and the inner borrow needed to return the expression
from the outer borrow. I don't believe it is important to support this.

Also, notice that class and linearity only exist on binders. These means
that that are, in a sense, shallow. They are only properties that the
topmost layer of objects can have. An object cannot be "deeply" second
class. It is possible to have objects that have deeper linearity annotations,
but I'm not sure that I want this. It complicates things.

Additionally, notice that the CPSed arrow doesn't play well with second-class
values. This is fine though. It's possible to define operations that use the
CPS arrow to project second-class fields from a second-class value. I'm not
sure what the use of this would be. Maybe something with mutable data that
doesn't rely on linear types (and isn't intended to be frozen). I need to
think about that later.

The CPS function arrow is kind of like an effect. It infects the types
of the expressions. We need to be able to eliminate it. The elimination
should look like this:

    run : (Unit{*} => b{*}) {1} -> b

This makes it so that nothing linear can escape. The entire block inside
of `run` gets moved around as a unit. This block tends to start with
`new` and end with `freeze` (or possibly `drop`). It would be nice if
we didn't have to pack things into tuples at boundaries, but I'm not
sure that I see a way around that. I guess that one option would be to
have the entire block export all of the nonlinear binders inside it,
but they are all members of the block. Access any of these binders
would force the block. The above example would instead be:

    dst0 <= new(100, True)
    dst1 <- write(dst0, 20, False)
    # Note: This hides the original dst1
    (block, dst1) <- borrow(dst1) fn(d : Array Bool):
      v10 <- index(d, 10)
      v20 <- index(d, 20)
    dst2 <- write(dst1, 10, False)
    () <= drop(dst2)
    pure(or(block.v10, block.v20))

Now that I see it, I don't like it.

I think that `run` might need to be more restrictive. The argument function
should not close over anything linear. But that's actually simple to enforce.
If we just mark the argument function as being consumed nonlinearly, then
a linear type system will naturally reject the terms we want it to:

    run : (Unit{*} => b{*}) {*} -> b

What's really going on when we combine CPSed and non-CPSed terms? In the
entry on 2024-05-06, I had a `lift` operation for this:

    lift : (a{m} -> b){1} -> (a{m} => b{1})

We ought to be able to take an non-CPSed term and lift it so that it can
be used in a CPSed setting. However, the requirement that the result of
type `b` be consumed linearly here seems wrong. I'm not sure that an
explicit `lift` operation like this is actually the right thing to do.
That is, when we have:

    dst0 <= new(100, True)
    dst1 <- write(dst0, 20, False)
    frzn <= freeze(dst1)
    ...

I think the semantic desugaring should be:

    withNew(100,True) $ \dst0{1}:
      dst1 <- write(dst0, 20, False)
      withFrozen(dst1) $ \frzn{*}:
        ...

Which does not need to lift `write`.

# Misc Thoughts

The PL experiment is going well. I'm able to parse and encode a primitive
subset of HTML. Escape sequences are currently ignored.

# Runtime Memory Management

I'll start by describing the simple system that I have devised. There
are two terms that I give a precise meaning:

* Page: A fixed-size block of memory. All pages must have the same size.
  In the proof-of-concept implementation that I've worked on, pages are
  4KB. But they could be 8KB or 16KB instead. Or they could be smaller.
* Region: A logical grouping of memory that shares a lifetime. Pages can be
  associated with a region. The total capacity of a region is the sum of
  all of its pages. When a region is destroy, all pages are disassociates
  and become available to other regions.

The fixed size of pages makes it easy to store metadata for them. What kind
of metadata do we need?

1. A reference to the region that the page is currently a part of.
   (Technically, this is not needed, but it's nice to have.)
2. A reference to the next block in the region, or a sentinel value
   indicating that this is the last page in the list of pages.

Both references are integers, not pointers. The region tracks the first page
and the last page. This makes it easy to walk the list of pages in order when
we are finished with a region. User allocations can only be satisfied by the
last page. The region keeps track of pointers into this one page. It's not
possible to look back at anything else.

This system works pretty well. I can fit the whole thing in my head.
It has two unusual features that I think make it cool:

1. The active page in a region has a downward bump allocator and an upward
   bump allocator. It's better to bump downward for known-size allocations.
   But there are some kinds of allocations (esp. arrays) where we aren't sure
   how much memory we will actually need in advance. Think about something
   like reading from a file descriptor. We'd like to let the `read` syscall
   populate as much of the page as we have available, but this cannot be
   a downward allocation.
2. We can use the page-chaining structure as a linked list of chunks for
   an array-builder effect.

I'm starting to run into something that I expect will eventually become a more
difficult problem: large objects. These are typically an unpleasant part of
runtimes. But I'd like to go ahead and think through it. The most simple way
to do this is to rely on `mmap` for these. These "large pages" should exist
in the page metadata array, but they need different metadata. We would end
up with something like this:

    small page
      region_id    : u64
      next_page_ix : u32
    large page
      region_id    : u64
      next_page_ix : u32
      memory       : ptr(u8)

The memory address of a small page is implied by its index. But a large page
is indirected. We can probably make this more uniform by just storing the
redundant address with the small page metadata.

An advantage of this strategy is that it's possible to remove the association
between the small page index and the address of the backing memory. We could
just add more (noncontiguous) memory as we needed it.

For large pages, it's easiest to just start with mmap, but we could eventually
switch to something that does not tinker with virtual memory as often. Consider
that with 4KB blocks and 1 mask bit per block, we could manage 1GB of
large-object heap with just 2^18 bits = 2^15 bytes = 32KB. Having to scan
this wouldn't be great since it could blow out L1 cache. But if the large-object
heap were smaller, maybe 64MB, then we would only need 2KB to manage it.
That's still not great. Maybe it could be broken into tiers, and different
tiers could have different granularity. But that gets more complicated, and
it could end up allocating a lot more memory than it needs to. Anyway, this
doesn't really matter for now since I should just use `mmap` until I'm forced
to figure something else out.

Sorry, I just can't let this go. What if we kept the mask array, but we just
built more layers on top of it? Suppose we break the mask into 16-bit segments.
What can we stack on top? (Suppose that 1 means "this block is free" and 0 means
"this block is in use".)

1. Disjunction. We can turn 16 bits into 1 bit by computing the answer to
   "are any of these blocks free".
2. Conjunction. We can turn 16 bits into 1 bit by computing the answer to
   "are all of these blocks free".
3. Population count. We can turn 16 bits into 4 bits by computing the answer
   to "how many of these blocks are free, minus 1, clipped at 0"

Population count is not great, and stacking multiple layers does not give us
anything useful. Disjunction and conjunction can be stacked, both independently
and with one another. They each have different uses. Disjunction is helpful
when we are trying to satisfy a request for a single block. Conjunction is
helpful when we are trying to satisfy a large request.

We could also blend these. For example, we could ask "are at least 9 of the
16 blocks available", which only requires 1 bit. But if it's true, it means
that there must be a run of at least two adjacent blocks available.
Alternatively, we could ask questions like "is there a run of at least N
blocks available"?

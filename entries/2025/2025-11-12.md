# Builders and Arrays

I recently redid the builder type so the type lines up with array better:

* `Builder(a)@r`: catenable builder with O(1) concatenation
* `Array(a)@r`: array

This was part of a change that forced all types to take a region argument
(even types that do not need a region argument). It has become possible
to make array a subtype of builder. They have exactly the same shape:
a pointer and a length. Builders also need a tag to track whether the
array is a bunch of elements or a bunch of builders. But the tag could
just be included in arrays as well and always set to mean "elements" there.

I had wondered for a while whether or not it was idea to do this. The
main benefit I had noticed was that it would make it easier to construct
builders. I've observed, in an example program that I worked on, that
the `Builder.Elements` data constructor (which is, at runtime, a no-op)
is noisy. It would be nice to just use an array as a builder. The drawback
is that it locks the language into certain implementation details, but
I don't see this as a big issue.

As I started thinking about parsing html (instead of just encoding it),
I found an additional benefit of the subtype relationship. The HTML data
types that we want for encoding and decoding are similar, but different.
They both have this shape:

    Node@r
      | Element
          tag : TextSeq@r
          attributes : Seq(Attribute)@r
          children : Seq(Node@r)@r
      | Text
          text : TextSeq@r

Above, `Seq` and `TextSeq` are placeholders. An encoder needs a flexible
Node type that is easy for users to assemble. It wants the collections
to be builders. A decoder is only going to produce nodes that use arrays,
not builders. But we would like to be able to take the result of decoding
and turn it into a builder-friendly type. And it should be possible to do
this as a no-op.

One way to do this is by having `Node` take a type argument for the
"builder status" of the node. I don't like this approach. That's the only
option you have in a language like Haskell, but it's very noisy. I'd
rather have a family of types with a relationship:

    type Attribute@r
      name : Array(Char)@r
      value : Array(Char)@r
    type AttributeBuilder@r
      name : Builder(Char)@r
      value : Builder(Char)@r
    type Html@r
      | Element
          tag : Array(Char)@r
          attributes : Array(Attribute)@r
          children : Array(HtmlBuilder@r)@r
      | Text
          text : Array(Char)@r
    type HtmlBuilder@r
      | Element
          tag : Builder(Char)@r
          attributes : Builder(AttributeBuilder)@r
          children : Builder(HtmlBuilder@r)@r
      | Text
          text : Builder(Char)@r
    Attribute <: AttributeBuilder
    Html <: HtmlBuilder

A disadvantage of this is that the `Attribute` types ends up being 32 bytes
instead of 24 bytes. It is possible to have two 64-bit pointer and two
32-bit lengths into 24 bytes, but once you add the tags, it no longer fits.
An easy solution (locking us into a very specific implementation of builder)
is to use negative lengths for `Builder.Builders` and positive lengths for
`Builder.Elements`. Then, builder becomes a 96-bit type.

One helpful implementation trick will be to not make this extensible. You
need to define an entire family of types all at once and all in the same file.

# Text and Arrays

What about this relationship:

    Text <: Array(U8)

This commits us to a particular encoding of text (utf-8), which I don't think
is a big deal. The more concerning issue is that `Text` is a type and `Array`
is a type constructor. It might be fine to expand a type into an applied
type constructor like this. I'm just not certain.

We cannot have `Text` be a type synonym of `Array(Char)` because that's not
how UTF-8 works.

Here are some types that we might need:

* Array
* Builder
* Text
* TextBuilder

But we could end up with this weird situation:

    Ascii : Type // note: Ascii is backed by an 8-bit word
    Ascii <: U8
    Array(Ascii) <: Text <: Array(U8)

All of this coheres, but I'm worried about subtyping decidability issues with
mixing type constructors of different arities like that. It's more simple to do
this instead:

    Ascii <: U8
    Array(Ascii) <: Array(U8)
    // Both of these functions are no-ops
    asciiToText     : Array(Ascii)@r -> Text@r
    getUtf8Encoding : Text@r -> Array(U8)@r

Ascii needs to be equipped with a refinement for restricting character sets. We
need something like:

    Ascii
    Ascii[a-z]
    Ascii[a-z0-9]

It is best to avoid refinement polymorphism if possible. It's probably fine
to do this for a few built-in primitives though:

    allAscii : {r : Region, c : CharSet}(Witness c, Array(U8)) -> Option(Array(Ascii{c})@r)

# Mutable Arrays, Builders, Refinements, Subtyping

Mutable arrays have to be invariant in their element type. But if it's a
mutable array that can only be written to (not read from), it is actually
fine to be contravariant in the element type. This extends to having an
array builder as an effect. For example:

    push : (a) -> () +{Writer(a)}

Specialized, we have:

    push : (Ascii[a-z]) -> () +{Writer(Ascii[a-z])}

And this can be called from a context with a larger writer effect like
`Writer(Ascii[a-z0-9])`. This is sound becaues read access is prohibited.

Strangely, there's not a way to get this to work with linear-style
mutable arrays. At least, not without introducing a kind of refinement
polymorphism that I am trying to avoid. With a linear mutable array, it
needs to look like this:

    push : {c}(Array(Ascii[a-z]), MutableArray(Ascii{c})) -> MutableArray(Ascii{c + [a-z]})
    or
    push : {c}(Array(Ascii[a-z]), MutableArray(Ascii{c + [a-z]})) -> MutableArray(Ascii{c + [a-z]})

Wait, there's a way for this to work. It relies on upcasting the argument array
instead:

    push : (Array(a), MutableArray(a)) -> MutableArray(a)

If the mutable has a type that is bigger than `Ascii[a-z]`, that's fine. The
array just gets upcasted to that type. This works, but it's not compositional
in the same way that the other solution was. That makes it impossible to lower
the earlier version down to this one.

Maybe there is a way. Suppose that we have this specialization:

    push : (Array(Ascii[a-z]), Writer(Ascii[a-z])) -> Writer(Ascii[a-z])

Is `Writer` covariant, contravariant, or invariant in its argument?
It is covariant. So the resulting writer here is fine. It's the argument
whose type will be difficult to satisfy. This will not work. The best
thing that can be done looks like this:

    push : {a,b}(a <: b, Array(a), Writer(b)) -> Writer(b)

Explicit subtype proofs are needed. But I think a lowering from the effect
system to the system that uses linear types should not be that difficult.
For example:

    encodePerson : Person -> () +{Writer(Ascii[a-zA-Z])}
    ==>
    encodePerson : {b}(Ascii[a-zA-Z] <: b, Person, Writer(b)) -> Writer(b)

Any calling context should already have the proof available. The type variable
is kind of annoying, but again, the calling context will always know how to
fill it in.

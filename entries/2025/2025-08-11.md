# More PL Thoughts

I skimmed the Mutable Value Semantics paper again this weekend. This time,
I realized what kind of system the paper was actually suggesting. It has
a way to make a mutable copy of immutable data, and this uses a copy-on-write
strategy to prevent it from being as expensive as it might otherwise be. It
also has something like rust's borrowing. It's called `inout` parameters,
and the type system requires that it be possible to track a `path` to
each `inout` parameter. Every `inout` parameter is second class, and the
type system has to make sure that they do not alias. This system is much
more similar to rust than I thought it was. I find it unsatisfying. It is
complicated, but it is also relies on COW, which results a compiler insearting
a lot of runtime checks when it lowers the code.

The blog https://www.scattered-thoughts.net has some pretty good posts.
It talks specifically about Mutable Value Semantics, and the author is
familiar with a lot of programming languages in this space.

# In-Place Freeze

I realized that it might be possible to simply not expose an in-place freeze
operation to the user. What if in-place freezing was just an operation that
the compiler performed when it detected that it was safe to do so? A compiler
could reliable detect this in nearly all cases that matter.

# Not Tracking Mutation as an Effect

I thought some about the value of `ST` by imagining a system more like SML,
but without mutable top-level variables. I realized several things:

* Without closures and without any kind of in-place freeze operation, there
  is less value in tracking mutation.
* `runST` lets us group operations that can be treated as one big
  opaque block (and moved around) by the compiler.
* If a function has no mutable input, then it is a pure function since there
  are no top-level mutable values. This property lets us recover a lot of the
  reasoning benefits that `ST` offers us.

Interestingly, we could still track whether or not a value was read-only or
read-write, and we could allow upcasting a read-write value to a read-only
value. This would make it possible to perform something like a "borrow" where
we run an operation that merely requires read-only access on mutable data.

The biggest drawback of a system like this is that it cripples a compiler's
(and sometimes even the user's) ability to reason about data. Suppose a
function takes two arguments of the same type, a read-only argument and
a read-write argument, like this:

    func incrAll(Array+rw S64, Array+r S64)(Unit)

This function's behavior is simple. Increment each integer in the source array
and write the incremented integer to the destination array. The expectation
we have in the function body is that the array's do not alias one another.
If they do, that limits the available implementation techniques. In this case,
it doesn't matter that much, but consider a similar function that reversed
the elements of an array. There, the possibility of aliasing would hinder
us more.

A system like this would inherit one of C's weaknesses. And that weakness is
that data that the user considers "immutable" is not really immutable. If you
read from an "immutable" object at some time during program execution and then
you read from it again later, you might get different results. Not only does
the compiler have to be prepared for this, the user has to be prepared for this
as well.

Maybe there is some kind of middle ground. Something like mutable vs immutable
vs "I'm not going to write to this, but it's fine if it's aliased by something
that is mutable". In this model, mutable and immutable are each modes that
can be attached to a value. The last mode, which I'll call "read only", is
something that implies less than either of these. We can upcast from mutable
to read-only, and we can upcast from immutable to read-only. The compiler
would treat it like a mutable value. That is, all accesses would be
sequentialized. But it would not be possible to write to the memory through
a read-only reference.

As a side note, it probably makes sense to restrict closures to closing
over immutable values only.

How do we get an immutable value from a mutable one? We could have a "freeze"
operation. This operation would often be optimized by the compiler so that
it was performed in place when possible. This is unsatisfying. If we get
rid of "immutable" and just have the other two modes, then freezing becomes
more simple. It just implies less, specifically concerning aliasing. I am
reluctant to give this up.

Still, this feels very close to be a good solution. It's just the freeze
operation that's giving me trouble, but that's not a serious problem.

This system makes it possible to have a low-level compiler IR where a
program is a graph. Operations on immutable data would result in dependencies
in a nice fine-grained way. Operation on mutable data would result in
sequentialized (probably oversequentialized) nodes with magic "sequencing"
dependencies. But even a crude type-based alias analysis could be used
to improve this.

# Uniqueness

I thought about uniqueness again. The last time I thought about it, I found
a difficult interaction between upcasting and GC. But I'm not thinking about
GC now, so this doesn't matter.

The whole borrowing thing is still a bit of a pain. It would be very nice to
be able to just borrow a unique value and temporarily use it as immutable
data.

The best thing about a uniqueness type system is how freezing works. It's
just an upcast. You drop the uniqueness annotation, and it's done. The value
is then considered "frozen".

A weakness of uniqueness type systems, shared by linear type systems, is that
they struggle to model multi-node mutable data structures like B-Trees and
some implementations of hashmaps. The interface provided at the boundary is
fine, but internally, it's difficult to get it to work.

The more I think about this, the more I am reminded that uniqueness is not
a good solution to enough of my problems.

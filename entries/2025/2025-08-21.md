# Regions, Packed Regions, and Objects

I've run into several difficulties in the past when I tried to bring all
of these features into one system. Here are the properties that I am
looking for:

* A packed region needs to be represented by a single pointer. An object
  needs to be represented by a single pointer. An object in a region
  could be either a pointer or an offset, but I think that an offset
  is best.
* Regions should not be able to point to reference-counted data. I've thought
  about how to make this possible, and I've realized that it has too many
  problems.

How can we get these properties? I think that all that is needed is to:

* Bifurate the universe of types. Region-managed types must be distinguished
  from RC-managed types.
* Introduce an indirection when packing an object with its existentially
  quantified region.

The bifurcation could work like this:

* KPrim: The kind of types that do not need to be "traced" (not exactly
  tracing, could mean reference counting).
* KAuto: The kind of types that require automatic memory management.

KPrim is a subtype of KAuto. Suppose we have an ordered map type that
uses automatic memory management and another one that does not (that is,
the map lives in a region, and then region's lifetime is managed in some
way, but not the individual nodes in the map). The map whose lifetime
is tied to a region cannot have values with automatically managed lifetimes.
The values need to be primitive types, or they need to be tied to other
regions. The two maps would have types like this:

    MapPrim : KPrim -> KPrim
    MapAuto : KAuto -> KAuto

Both can be applied to a primitive type like `S64`, but only `MapAuto` can
be applied to another automatically managed type.

Interestingly, it's possible to only build half of this system and then
add the other half later. And either half could be built first. For certain
tasks, you would need duplicated APIs for things. POSIX, for example. If
you wanted to read bytes from a file descriptor, you would need to know
if you were dealing with a GC-managed byte array or one that was in a region.
Also, arrays are tricky. It's really important to be able to share code that
works on arrays.

A generic way to lift an unmanaged object into the managed world is this:

    Managed : (Region -> KPrim) -> KAuto
    manage  : {f : Region -> KPrim} -> (r : Region) -> f r -> Managed f

It might even be possible to implement `Managed` without having it be a
primitive. It's just a data constructor with the region (some kind of
handle to it) and a pointer to the object inside it. The handle
to the region is needed so that, when the managed wrapper goes out of
scope, we can follow it to find an RC to decrement. So, there are two
layers of counters here. This has to be done this way for uniformity.
Anything managed needs its counter at the beginning of the object. The
counter for a region is necessarily not adjacent to any of the objects
in the region. It could be, at most, adjacent to one of them. So, it's
possible to have a "root object" system for managed, which would make
it possible to flatten things out a little. But it's also less flexible.

Let's go back to arrays. One important difference between a managed
array and a region-allocated array is that the managed array needs a way
to keep track of its reference count. So it's not just one pointer.
It's a pointer to somewhere in the array, and it's a pointer to the RC,
and it's the length. The region-allocated array only needs a pointer
to an element and a length. So maybe this is how packed objects should
work too. Arrays will already need to do this. And then borrowing
(especially from an array) would expose a second-class alias of
the array that didn't need to keep track of the RC pointer.

To spell this out more clearly, the trick is that packed regions and
natively managed objects do not have the same size. The former is
two pointers (maybe three) and the latter is one pointer. However,
the representations both have a pointer to counter as their first
element. For natively managed objects, this pointer aliases the
object itself. One other thought to consider is that packing is not
actually a hard requirement. It is nice to have, but it can lead to
tricky issues where space is wasted since to have no way to tell the
runtime that we are done allocating into a region.

That works. Any function that consumes an array should be defined to
consume an array that's it a region. Any function that returns an
array might need to be defined both ways.

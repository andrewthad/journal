# Thoughts on C Codegen

I recently stepped through a generated C programs with gdb to find a mistake.
It was neat that this was even possible. Without lowering to C, it would not
have been possible. The readability of the C program is not very good. It's
not completely unusable, but it could be better. This post is about issues
that I have noticed.

## C23 Struct Compatibility Improvement

C23 makes it possible to repeatedly define the same struct like this:

    struct foo {int x, y;} my_func(int z) {
      return (struct foo {int x, y;}){.x = z, .y = z};
    }

You still have to pick a name for the struct (here, `foo`), or it is not
considering compatible. Starting from, GCC 14 (compiling in C23 mode), this
is allowed.

## GDB And Unsigned Char Pointers

I have been using `unsigned char*` in a lot of places to represent the payload
of an array. This makes it difficult for GDB to inspect arrays. Improving this
might be possible. Originally, I had tried to do define a bunch of different
array types:

    // This first one is for arrays with an unknown element type (like in a
    // polymorphic function)
    struct array {
      int32_t length;
      unsigned char* payload;
    };
    struct array_u16 {
      int32_t length;
      uint16_t* payload;
    };
    struct array_u32 {
      int32_t length;
      uint32_t* payload;
    };

But this was going to become complicated once users were able to defined
their own types.  However, C23 makes it possible to just define
`struct array_person` and `struct array_foo` on the fly. They do not
have to exist at the top level. So I think that it's worth revisiting
this decision. With ADTs, I've already ended up in a situation where
I need to explicitly upcast in C code. So I may as well continue down
that path here.

One issue is that it's not possible to improve this for recursive data types
that require polymorphism. For example:

    struct list {
      struct list* tail;
      unsigned char head[];
    };

It's tempting to try to do this:

    struct list_u16 {
      struct list_u16* tail;
      uint16_t head;
    };

Or possibly this variant:

    struct list_u16 {
      struct list* tail;
      uint16_t head;
    };

Neither of these are compatible with the first struct. So it might just be
arrays that it's possible to do this with. But it still might be worth doing
this even just with arrays. It would certainly make reading and writing more
natural. Here's an example of a difficult-to-read lowering of
`builder.concatenate` followed by `array.map`:

    struct array const chArr = builder_concatenate(r, 8, ch);
    struct array const childrenEncodings = {.length = chArr.length, .payload = allocate_bytes_small(r, (size_t)16 * chArr.length)};
    for (size_t i = 0; i < chArr.length; i++) {
      ((struct builder*)childrenEncodings.payload)[i] = encodeHtml(r, ((struct html_builder**)chArr.payload)[i]);
    }

Better array types would give us this instead:

    struct array_html_builder const chArr = builder_concatenate(r, 8, ch);
    struct array_builder_u8 const childrenEncodings = {.length = chArr.length, .payload = allocate_bytes_small(r, (size_t)16 * chArr.length)};
    for (size_t i = 0; i < chArr.length; i++) {
      childrenEncodings.payload[i] = encodeHtml(r, chArr.payload[i]);
    }

This is much easier to understand.

## Fresh C Variables Names

I need a way to create C variables in the generated code. I was thinking of a
naming convention like this:

* In the source language, variable names beginning with underscore are not
  allowed.
* In the generated code, all locals are prefixed with `v_`. All top-level
  constants are prefixed with `c_`. All top-level functions are prefixed
  with `f_`.

And now there are no conflicts. It might make more sense to leave function
names alone though and only prefix local variables instead. Function names
will show up in profiling and in stack traces. Local variables only show up
in GDB.

## Avoiding Duplicate Casts When Projecting

Take a look at this:

    switch (html->tag) {
      case UINT32_C(0): ;
        struct array const text = {.length = ((struct html_builder_text*)html)->text_length, .payload = ((struct html_builder_text*)html)->text_payload};
      default: ...
    }

Gross. If variables were all prefixed, we could do this instead:

    switch (v_html->tag) {
      case UINT32_C(0): ;
        struct html_builder_text* z_html = (struct html_builder_text*)v_html;
        struct array const v_text = {.length = z_html->text_length, .payload = z_html->text_payload};
      default: ...
    }

This is not a silver bullet. We probably need to use an incrementing
identifier instead to prevent duplicate identifiers (e.g. `v23_html`).

## Doing More Inline in C Expressions 

I gave up on a true ANF after a while. Here are the reasons:

* It's really unpleasant to write code this way.
* The C backend does not need full ANF. In C, you can write `foo(bar(x))`
  without needing to invent a name for the result of `bar(x)`.

However, I've encountered some difficulties. Allocating anything on the
heap is a multi-statement operation. So, we end up needing little wrapper
functions for every possible kind of allocation. And polymorphic types
need an allocation wrapper for all possible size classes. This is all
doable. I'm just trying to remind myself that it's worth doing. Already
I have things like this for arrays:

    struct array const resultArray = allocate_array_generic_3(r, 16, (unsigned char*)&openBuilder, (unsigned char*)&childrenEncodingsBuilder, (unsigned char*)&closeBuilder);

Although I will probably switch to one of these instead:

    struct array_builder const resultArray = allocate_array_builder_3(r, 16, openBuilder, childrenEncodingsBuilder, closeBuilder);
    struct array_builder const resultArray = allocate_array_builder(r, 3, 16, [openBuilder, childrenEncodingsBuilder, closeBuilder]);

Wrappers for data types will look like this:

    struct list list_cons(struct region_handle* r, size_t sz, unsigned char* head, struct list* tail)

The implementation allocates and uses `memcpy` to set the head. However, this
function makes it difficult to use an integer literal as the head. It is probably
desirable to have several variants:

    struct list list_cons_u8(struct region_handle* r, size_t sz, uint8_t head, struct list* tail)
    struct list list_cons_u16(struct region_handle* r, size_t sz, uint16_t head, struct list* tail)

# Requiring Thate All Atoms Can Be Lowered to C Expressions

I think it should be possible to lower *any* atom to a C expression. For
`array.map`, I know that this is not going to result in the most efficient
C code. But it is at least possible. It needs to use a function pointer,
and every function needs wrappers (to homogenize the calling convention).
This seems like a bit of a mess. GCC supports using a compound statement
as an expression, but that's nonstandard, and it would be hard to render
it nicely.

An easier solution is to just generate monomorphizations of `array.map`
at the top level (marked as `static inline` or just `static`) wherever
they are needed. Each monomorphization would call the correct function.
There would not be any function pointers.

# Arrays and Builders

This is something that I'm still on the fence about. In the source language,
I don't like the cumbersome step of turning an array into a builder. After
all, it's actually a no-op. Here's how this lowers to C:

      struct array const resultArray = allocate_array_generic_3(r, 16, ...);
      struct builder resultBuilder = {.tag = 1};
      resultBuilder.builders_payload = resultArray.payload;
      resultBuilder.builders_length = resultArray.length;

This could be cleaned up:

      struct array const resultArray = allocate_array_generic_3(r, 16, ...);
      struct builder const resultBuilder = {.tag = 1, .builders_payload = resultArray.payload, .builders_length = resultArray.length};

But it would be better to dispense with this entirely. After all, the shape
of these two types is identical.

The reason to not do this is that the upcasting path is strange. Builders
are struct-like types, not associated with a region. Arrays are associated
with a region. This kind of strange suggests that the builder type should
be redone to match the array type more closely: `Array(a)@r` and
`Builder(a)@r`. Which, to be honest, would be nice for a lot of other
reasons. Mostly, it's just easier for the user to remember where region
annotations go this way.

An alternative to this is to make the backend deeply match expressions
like `Builder.Elements([foo,bar]@r)` to avoid generating C code with
redundant data movement.

# Writer Without Region Annotation

I've starting using the term "writer" to refer to an abstraction where
the user pushes elements into an array. The array has a fixed size
and cannot grow. This abstraction is nice for several reasons:

* Initialization is not necessary
* Bounds checking can be omitted. This introduces undefined behavior,
  but it's possible to instead perform a single check at the end that
  ensure that misuse cannot go unnoticed.

# Finalizing Writers

Finalizing a writer is simple. You just need to get the pointer to the
beginning of the buffer. Since the writer is just a pointer to the current
element, it's not possible to use it to recover the pointer to the initial
element. So the base pointer (the pointer to the initial element) needs
to be tracked separately.

How to we make sure we put the right two pointers back together? One option
is to use a phantom type variable that doesn't unify with anything else.
This pollutes type signatures though, and it's meaningless noise. A different
strategy is to store both the initial pointer and the length as the "base".
Then, when finalizing, we check that the base, the length, and the final
pointer agree with one another.

Something nice about this is that the writer itself doesn't even need to
talk about a region. The region annotation is attached to the base (which
doesn't get threaded through a bunch of functions), and it can be recovered
that way. The writer cannot outlive the base. Here are the types:

    new      : Unit => (Base(a)@r {1}, Writer(a) {1})
    finalize : (Base(a)@r {1}, Writer(a) {1}) => Array(a)@r

# Removing More Annotations

It would be nice if it were possible to remove more region annotations. As
an example, arrays that are merely consumed don't really need to be annotated
with a region. It doesn't matter what region they live in. The important thing
is that the array does not somehow outlive the region.

With writers, it was possible to exploit linear use to make sure the region
did not go out of scope before the writer. But here, we are not so fortunate.
Something like this would work:

    withArray : (Array(a)@? {2} -> b) -> Array(a)@r -> b

But the ergonomics of this are not great. Let's try the CPS arrow:

    liberate : Array(a)@r => Array(a)@? {2}

That's more pleasant to use, but now it's difficult to figure out when
the region goes out of scope. It needs to be something like "at the end
of the CPSed block". That actually works out fine. The second-class values
must already be prohibited from being returned in this way because of
something I want to do with guaranteed stack allocation. 

I've written about something similar on 2024-09-16. The interesting thing
at that time was that I came up with some bizarre rules that prohibited
region variables from being instantiated with the top region. I don't like
that solution.

It would be neat if `liberate` could just be an upcast. That would require
less syntax. Maybe it can be. It's a little tricky. We want to make sure
that there are no first-class values of the type `Array(a)@?`. So it's not
an ordinary subtyping relationship. It's one where we make two adjustments
simultaneously. Overall, I like this, and I think it's a good idea. It's
going to make a lot of stuff easier to work with.

What about for ADTs? I think we can do the same thing. Projections need to
preserve the second-class nature of the object though. For arrays, there's
no benefit in doing because they are parametrically polymorphic in their
element. For example:

    index : Array(a) {2} -> S32 -> a           // Result is a first-class value
    head  : Cons(a,r)@s {2} -> a               // Result is a first-class value
    tail  : Cons(a,r)@s {c} -> List(a,r)@r {c} // Preserves the class

The dual regions annotations on `Cons` and `List` make it clear why this
does not work for structurally recurive types. We cannot actually hide both
of the annotations correctly. We can only hide the outer one. I need to
think about this more. I don't like the class variable used in `tail`.

# Improvement

We need to be able to upcast to a top region. Imagine that we can do this:

    Array(a)@r <: Array(a)@T

But only for second-class bindings. This works fine for arrays. Here are the
shortcomings:

1. It does not work well for recursively defined data types
2. It does not give the user a way to remove the annotation on an element type.

There's a different approach where the second-class nature of a binding infects
all child objects reachable through that binding. This requires that the function
for indexing into arrays have a different type signature:

    index : Array(a) {2} -> S32 -> a {2}

This is unacceptable. We might need the result to escape the calling context.

# Another Idea

What if we did something more like existential packing, but we used
second-class values to prevent the packed region from escaping? The idea is
something like this:

    pack : (r : Region) -> Object@r -> Packed(Object) {2}

How is this any different? It's unpacking that's different. We can unpack
like this:

    unpack : Packed(Object) {2} -> (r : Region {2}, Object@r {1})

We don't even really need second-class types for this. We can just have
a restriction that functions cannot return existentially quantified regions.

We need for the conversion to a packed object to be implicit:

    Object@r <: Packed(Object)

I don't think this will be a big deal though. It should be fine to perform
this conversion anywhere at any time because it's not possible to smuggle
anything existentially quantified out of the function. Actually, I'm not sure
whether or not this will work correctly. What prevents the value from being
returned. We still need some kind of second-class annotation. Because we
cannot take these packed values and embed them into anything. The only
real difference between this and what I proposed earlier is the way that
an unknown region is dealt with. Packing and unpackin a list looks like this:

    pack2   : List(a,r)@r -> Packed(List(a))
    unpack2 : Packed(List(a)) {2} -> (r : Region {2}, List(a,r)@r)

I really need to figure out a way to get rid of the double region annotations
on List. Notice that unpacking turns the value back into an ordinary list.
Interestingly, the list is actually eligible for 1st class use. It's only
the region that must not escape.

Can we hide the annotations on the elements this way? No, the pack function
can only be run at the top level (since the result is 2nd class). So this
fixes the problem with List, but it is not great beyond that.



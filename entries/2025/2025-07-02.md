# Build Tools

When a build tool is layered on top of a compiler, the user experience
suffers. Why does this happen? One difficulty is that the build tool
chooses what flags/options to set when it invokes the compiler. The
user has no insight into this. It's possible for a compiler to have
features like profiling and cross compilation, but if the build tool
does not expose these, they are unavailable to the user.

# Dependent Types

I keep coming back to this over and over. The most recent project where
I tried this out was dtlight. It had a true dependently typed core language,
where terms and types were the same thing. It also has refinements and
subtyping. I didn't run into any serious problems with how these interacted
with dependent types. An ergonomic problem that I had was that the inferred
(or synthesized) types for certain terms could get tedious. A more serious
problem was that I realized that, for type equality to be both correct and
ergonomic, it would be necessary to expand any binder used as a type into
its definition.

There are a few options. Because of how regions work, it's not a good idea
to get rid of dependent types entirely. But regions only require a very
weak version of dependent types. The "let region" construct always introduces
a fresh region that is not equal to any other region. This means that if
this is the only form of dependent types, dependent type equality becomes
simple. It is never necessary to expand anything.

The option that I am most interested in is to distinguish between terms
that can be used as types and terms that cannot. This bifurcates the universe
of values. Regions and natural numbers can appear in type signatures. Values
of most other types cannot. What is gained by this? Mostly, simplicity.
We do not get real proof terms. This means that we lose some expressive
power. For example, many of the proofs from 2025-06-28 cannot be described.
But even if we did have some of those proofs, they would be difficult
to use. Maybe for Arrow's ListView there is a crummy built-in solution with
a type like this:

    data Slice : Nat -> Type = ... // a pair of i32 where the sum is bounded by n
    slice : Array n a -> Slice n -> Array ? a
    data SliceSoa : Nat -> Nat -> Type
    indexSliceSoa : SliceSoa m n -> (I32 | < n) -> Slice m

This works, but it requires a special type. And it requires a built-in function
that constructs a `SliceSoa` from two i32 arrays (verification of the invariant
happens there). This might not be the only time that it's useful to promote
a tuple-like type to an SOA variant.

# Compiling a High-Level Language Directly to C

I realized recently that if the compilation target is C instead of assembly,
it becomes possible to lower a language that is not in A-Normal Form. This
means that it might not even be necessary to have linear types. It should
be possible to handle mutation and IO with a monadic approach. And regions
could be handled with a callback.

# Regions and Subtyping

It needs to be possible to conveniently use an object in one region as an
object in a child region. This can be done with a proof term, or it can
be done by adding some kind of additional context to the type system that
indicates which regions live in other regions.

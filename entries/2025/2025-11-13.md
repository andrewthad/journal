# Str and StrBldr

I think that, after the post on 2025-11-12, I have a better idea of the
hierarchy that I want. It looks like this:

    // Note: UType means "untethered type", i.e. still needs a region
    Arr     : Type -> UType
    Bldr    : Type -> UType
    U8      : Type
    Ascii   : CharSet -> Type
    Str     : UType
    StrBldr : UType
    Arr             <: Bldr
    Str             <: StrBldr
    Ascii(c)        <: U8
    Arr(Ascii(c))   <: Str
    Bldr(Ascii(c))  <: StrBldr
    // All of the convert functions are no-op functions, but they
    // cannot be casts.
    conv.str.arr      : Str@r     -> Arr(U8)@r
    conv.strbldr.bldr : StrBldr@r -> Bldr(U8)@r

The subtype relationships between types and applications of type constructors
are worth thinking about. The concern that I have is that it might mess up
type inference. We could do this instead: 

    Arr     : Type -> UType
    Bldr    : Type -> UType
    U8      : Type
    Ascii   : CharSet -> UType // Ascii is now an array of characters
    AsciiBldr : CharSet -> UType
    Str     : CharSet -> UType
    StrBldr : CharSet -> UType
    Arr       <: Bldr
    Str       <: StrBldr
    Ascii     <: Str
    AsciiBldr <: StrBldr

This is kind of pointless though. If `Str` is equipped with a refinement,
there's no reason to have `Ascii`. We should just have this:

    Arr     : Type -> UType
    Bldr    : Type -> UType
    U8      : Type
    Str     : CharSet -> UType
    StrBldr : CharSet -> UType
    Arr       <: Bldr
    Str       <: StrBldr
    conv.str.arr      : Str(c)@r     -> Arr(U8)@r
    conv.strbldr.bldr : StrBldr(c)@r -> Bldr(U8)@r

This is fine, but it leaves us without a way to talk about "arrays of ascii
characters". When we know we are dealing with only ascii characters, it
would be nice to have access to all the fast array functions that can
perform O(1) indexing. We could do something like this:

    conv.str.ascii : Str(c)@r -> Arr(Ascii(toAsciiSet(c)))@r

The requires a special type-level function that fold a codepoint predicate
down to an ascii reinterpretation of the UTF-8 encoding. It's not that
bad though. I think that it might be best to not have any built-in subtype
relation between `Ascii` and `U8` since they have different arities. Also,
there needs to be some kind of convenient syntax that lets us omit the
refinement from `Str` most of the time.

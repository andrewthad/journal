# Arrow Maps

In the python repl, I built a dataframe with this schema:

    pyarrow.Table
    attributes: map<string, string, keys_sorted>
      child 0, entries: struct<key: string not null, value: string> not null
          child 0, key: string not null
          child 1, value: string
    identifier: int32
    ----
    attributes: [[keys:["FirstName","LastName"]values:["Martha","Washington"],keys:["FirstName"]values:["Cynthia"],keys:["FirstName","LastName"]values:["Steve","Martin"]]]
    identifier: [[50,67,300]]

Then, I serialized it to disk. The file ends with `7801 0000 4152 524f xywz`.
The last six bytes are a magic ID, and `7801 0000` is the litte-endian
representation of a length: 0x0178 or, in decimal notation, 376. The
footer is this part of the file (shown with `xxd`):

    00000370: 1000 0000 0c00 1400 0600 0800 0c00 1000  ................
    00000380: 0c00 0000 0000 0400 3400 0000 2400 0000  ........4...$...
    00000390: 0400 0000 0100 0000 6001 0000 0000 0000  ........`.......
    000003a0: 6001 0000 0000 0000 a800 0000 0000 0000  `...............
    000003b0: 0000 0000 0800 0800 0000 0400 0800 0000  ................
    000003c0: 0400 0000 0200 0000 4400 0000 0400 0000  ........D.......
    000003d0: 58ff ffff 0000 0102 1000 0000 2400 0000  X...........$...
    000003e0: 0400 0000 0000 0000 0a00 0000 6964 656e  ............iden
    000003f0: 7469 6669 6572 0000 0800 0c00 0800 0700  tifier..........
    00000400: 0800 0000 0000 0001 2000 0000 94ff ffff  ........ .......
    00000410: 0000 0111 1400 0000 2800 0000 0400 0000  ........(.......
    00000420: 0100 0000 2400 0000 0a00 0000 6174 7472  ....$.......attr
    00000430: 6962 7574 6573 0000 0000 0600 0800 0700  ibutes..........
    00000440: 0600 0000 0000 0001 98ff ffff 0000 000d  ................
    00000450: 1800 0000 2000 0000 0400 0000 0200 0000  .... ...........
    00000460: 6000 0000 2400 0000 0700 0000 656e 7472  `...$.......entr
    00000470: 6965 7300 94ff ffff 1000 1400 0800 0600  ies.............
    00000480: 0700 0c00 0000 1000 1000 0000 0000 0105  ................
    00000490: 1000 0000 1800 0000 0400 0000 0000 0000  ................
    000004a0: 0500 0000 7661 6c75 6500 0000 ccff ffff  ....value.......
    000004b0: 1000 1400 0800 0000 0700 0c00 0000 1000  ................
    000004c0: 1000 0000 0000 0005 1000 0000 1800 0000  ................
    000004d0: 0400 0000 0000 0000 0300 0000 6b65 7900  ............key.
    000004e0: 0400 0400 0400 0000

I'm able to pretty print this with `flatc`, althought I don't fully understand how it
knows what type to resolve this to:

    /home/amartin/Downloads/flatc --raw-binary --json --strict-json File.fbs -- /home/amartin/Data/Development/ir-app/people-with-attrs-footer.binary

Now we can see the footer:

    {
      "version": "V5",
      "schema": {
        "fields": [
          {
            "name": "attributes",
            "nullable": true,
            "type_type": "Map",
            "type": { "keysSorted": true },
            "children": [
              {
                "name": "entries",
                "type_type": "Struct_",
                "type": {
                },
                "children": [
                  {
                    "name": "key",
                    "type_type": "Utf8",
                    "type": { },
                    "children": [ ]
                  },
                  {
                    "name": "value",
                    "nullable": true,
                    "type_type": "Utf8",
                    "type": { },
                    "children": [ ]
                  }
                ]
              }
            ]
          },
          {
            "name": "identifier",
            "nullable": true,
            "type_type": "Int",
            "type": {
              "bitWidth": 32,
              "is_signed": true
            },
            "children": [ ]
          }
        ]
      },
      "dictionaries": [ ],
      "recordBatches": [
        {
          "offset": 352,
          "metaDataLength": 352,
          "bodyLength": 168
        }
      ]
    }

Now let's find the record batch metadata. The batch starts at byte
352, or 0x160:

    00000160: ffff ffff 5801 0000 1400 0000 0000 0000

There are four continuation bytes `ffff ffff`, and then the length of
the record batch metadata is encoded an additional time, except that
this time, it's 8 bytes less because it does not include the continuation
bytes or the length (0x0158 instead of 0x0160). If we grab the relevant
bytes and run them through flatc, we get this:

    {
      "version": "V5",
      "header_type": "RecordBatch",
      "header": {
        "length": 3,
        "nodes": [
          { "length": 3, "null_count": 0 },
          { "length": 5, "null_count": 0 },
          { "length": 5, "null_count": 0 },
          { "length": 5, "null_count": 0 },
          { "length": 3, "null_count": 0 }
        ],
        "buffers": [
          { "offset": 0, "length": 0 },
          { "offset": 0, "length": 16 },
          { "offset": 16, "length": 0 },
          { "offset": 16, "length": 0 },
          { "offset": 16, "length": 24 },
          { "offset": 40, "length": 43 },
          { "offset": 88, "length": 0 },
          { "offset": 88, "length": 24 },
          { "offset": 112, "length": 34 },
          { "offset": 152, "length": 0 },
          { "offset": 152, "length": 12 }
        ]
      },
      "bodyLength": 168
    }

This is what I wanted to see. There's a lot of buffers in there, and I want
to be sure that I understand why each of them is present. Every buffer with
length zero is an omitted bitmap. The last buffer (offset 152) is the IDs,
an array of 3 32-bit integers.

The second buffer is (offset 0, length 16) is the indices of an array. There
are 3 elements, so we need 4 32-bit indices.

The third buffer is a mask for the Struct. I suspect that this will always
be empty. Buffers 4, 5, and 6 go together. They are for the keys, which use
the VarBin layout (mask, offsets, values). Same thing for buffers 7, 8, and 9.
And that's it for the buffers.

The nodes are similar. The first one is for the list, the second for the struct
(again, kind of pointless), the third for the keys, the fourth for the values,
and the fifth for the IDs.

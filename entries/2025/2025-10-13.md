# A Few Thorns

Here are some tricky issues with regions:

* Stack-allocated values do not need a region annotation. However, they
  may refer to objects that do live in regions. So a region annotation
  is needed, but it is not in the usual place.
* Recursively defined type constructors (e.g. List) need the annotation
  to apply to the entire spine. It's difficult to do this. All of my
  attempts to do this so far have ended up annotating lists with the
  same region twice, which is undesirable.

Here are some tricky issues with effects:

* Some effects work very naturally as sets. All of the stuff for working
  with regions is better as a set, not a list. Also, IO works with a set
  of effects.
* A primitive that introduces a region cannot possibly create a region
  with the same name as an existing region. The means that the Haskell
  mtl problem with two `ReaderT`s with the same environment type cannot
  happen. This is good.
* Once we start adding other effects, the set thing can fall apart. If we
  want to keep treating effects as a set, we need to prohibit effect
  polymorphism. Whenever we introduce an effect, we need to make sure
  that it isn't already present. Effect polymorphism is only useful in
  the presence of HOF. For example: `map : (a ->{e} b, Array a) ->{e} Array b`.
  Inside the callback, we might want to layer another effect on top, but
  we cannot add an arbitrary effect to set since the set might already
  contain it. What's interesting is that we can have a little bit of effect
  polymorphism. We just cannot add more effects on top of an unknown effect
  set.

And here is the tricky issue with how regions and effects interact:

* Subregions. We need to be able to treat a upcast any immutable object
  living in a parent region and use it as though it were part of a child
  region. If effects are a set, they will not be ordered, so we cannot
  try to discern any kind of relationship that way. Maybe the relationship
  should just be another effect. That works, and it can be lowered to
  something direct style if I ever need to do that. So we would have effects
  like `{Alloc(r), Alloc(s), r <: s}`. That should be fine.

So, I think I have a decent answer to most of these questions. I'm still stuck
on the issue about lists and struct-like types. One option is to have the
region annotation work as a special type parameter. It would need to be the
first argument (instead of the last argument) to a type constructor. For
example: `List@r(U8)` instead of `List(U8)@r`. Or it could still be last,
but it would need to be possible to refer to it when defining the data
constructors of a type constructor. Or maybe syntactic sugar is the solution.
What if we used `List(U8,r)@r`, but trailing arguments could be omitted.
So we would write `List(U8)@r`, and the arity mismatch would cause the last
argument to be defaulted to `r`. This is not too bad. It would make HKT
confusing, but I don't really care too much about that.

And what about struct-like types like `Builder`? I would like for it to be
possible for a user to write out `Builder(U8)@r` even though the true type
is `Builder(U8,r)`. I'm not sure what to do here.

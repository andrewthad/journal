# Array Writers, Again

On 2025-09-03 and 2025-09-04, I worked on schemes for array writers. If I'm
going to have primitives that take function arguments (as I suggested on
2025-09-17), I might as well just have `withWriter` available directly:

    withWriter : (Writer {1} -> Writer) -> Array

It probably needs to take a size (or max size) argument as well. What if
we need this to be able to fail?

    withWriter : (Writer {1} -> Result e Writer) -> Result e Array

This doesn't quite work. If we return an error from the function, there's
no way that it would consume the writer linearly. Really, we need to be able
to run this in any algebraic effect:

    withWriter : (Writer {1} ->{eff} Writer) ->{eff} Writer

Again, there's a problem with exception-like effects. Additionally, this
just isn't very low level.

It is nice if this works in IO though. For example, using the big arrow
for a function that operates in IO:

    withWriter  : (Writer {1} => Writer) => Writer
    exitProgram : a {1} => ()

We may want the same in any mutating context.

# Scoping Mutation, Again

I worked on this idea yesterday and came up with this:

    run : ({r : Region}(Handle(r), a) -> b +mut(r)) -> a -> b

But thinking about it again, I had a more simple idea. What if there is
a simple "mutation" effect? That is, what if we remove the tag from it?
Let's use `->` for pure functions, `=>` for mutating functions, and
`!=>` for IO functions:

    run : ({r : Region}(Handle(r)) => b) -> b

This does not work. We could nest `run` inside of `run`, and the inner
invocation would be able to write to mutable objects from the outer invocation.
Ways to prevent this:

* Somehow make `run` non-reentrant with the type system. This is not
  a good idea.
* Somehow clear mutable values from the context when evaluating the function
  given to `run`. This interacts poorly with polymorphism though. It's hard
  to tell if a type variable is a mutable type or an immutable type.

Maybe pairing mutation with a region is the wrong choice. Suppose we have a
function like this:

    scramboli : {r, s, t : Region}(Handle(r), Handle(s), Handle(t)) => X

We should expect that this function may allocate data in any of these regions
and that it may mutate the allocated data. This suggests that `run` should
look like:

    run : (a => b) -> a -> b

But with restrictions on `a`. It cannot be possible to close over mutable
data or over anything polymorphic, since it could be mutable. This is
unsatisfying. We might need to deal with values with polymorphic types
from the context.

Having the effect be tagged with a region or state token seems like the right
thing to do. It solves all of the problems that I'm having. It's just
frustrating to have to do this. It syntactically burdens the system. This
is evident in GHC Haskell's ST system. In nearly all cases, there's a single
type variable, often named `s`. Compare these:

    write : (MutableArray s a, Int, a) -> ST s ()
    write : (MutableArray   a, Int, a) -> ST   ()

The second one is cleaner.

What if the solution was to push all of the magic into `run`? Suppose that
`run` closes over everything, but it rewrites the context so that the types
of mutable data become fresh types that do not unify with anything. These
values can even be returned, but they get turned back in the end. This
strategy is pretty weird. I'm not familiar with any prior work like this.
It has some issues with mutable data that's nested inside of an immutable
data type. Its behavior in the presence of polymorphism is fine. It also
works fine with nested uses of `run`.

Maybe this is worth pursuing. It's possible to do a simple initial implementation
where `run` only closes over values that are immutable, or even just a subset
of immutable values. Support for integral types and arrays of them would
probably get me 90% of what I need. The "immutable spine, mutable leaves"
data structures are never going to get closed over correctly. But at least
I won't have a bunch of phantom type variables in all my function signatures.

A disadvantage of this approach is that it's impossible to lower it to a
"direct style" representation.

Maybe annotating the arrow more heavily is the right choice. It's actually
easier for the end user to deal with region handles this way than it is
to manually thread the region handle through the program. I need to come
up with a better notation for this. The effects that I can think of are:

* IO (`io`)
* Read from mutable objects in region (weakest region cap) (`t` or `t+r`)
* Allocate into region (`t+a`)
* Write to mutable objects in region (`t+w`)
* Mutation of GC object (`s+w`)

Except for the "allocate into region" effect, none of these require passing
anything at runtime. When mutating a GC-managed object, we have to pair the
object with a "pseudoregion" (called `s` in the example above). Actually, we
have to know somehow that these are not regular regions because allocating
into them will look different.

The effect-based solution is nice because there is a way to lower it to
direct style (should the need ever arise). It's also nice because there are
a few other simple effects that it would be nice to use. These include
Haskell's reader, writer, state, and exception effects. The exception effect
can have a finnicky relationship with linear types. Sometimes, you want
to be able to destroy a linearly consumed resource. For example, if you are
initializing an array, it makes sense to be able to bail out. But if the
linearly consumed resource is something like a file descriptor, this is
undesirable.

# Base Effects and Layers

A common problem with effect systems is that it can be difficult to layer
additional effects. For example, in Haskell, consider an expression of the
type:

    StateT Foo (StateT Foo Identity) Bar

Types like this are annoying and not terribly useful. We can use `lift`
to pick the layer of the stack that we are dealing with. We can also use
type-directed solutions, but those do not work when there are multiple
states with the same type. My preference is to just not support this.
The classic Haskell effects (called monad transformers in the Haskell
ecosystem) all have crummy layering behaviors. But mutability and allocation
effects that I'm thinking of do not have this issue. The reason is that
my effects are (not sure if this is the right word) idempotent. They are
more like capabilities in this way. For example, if we have the ability
to mutate objects in region `r`, having that ability twice doesn't change
anything.

We could just disallow abstraction of effects entirely. That's probably
the easiest thing to do to get started. Eventually, it would make sense
to let users temporarily layer a mutation effect on top of the classic
RWST effects. But I don't need that right now.

Also, I would like a "parser" effect as well. I know this can be modeled
as a combination of reader and state, but a dedicated parser effect would
lower to C code that is much nicer to read (and might perform better too).

# Possible Syntax for Effects

What about this as a syntax:

    posixWrite : {r}[IO](Fd, Arr(U8)@r) -> ()
    arrayWrite : {r,a}[Write(r)](MutArr(a)@r, S32, a) -> ()

In order:

* Type variables (curly braces)
* Effects
* Argument types
* Result type

Notice that effects can reference type variables. The "write" and IO effects
both suggest that the operation needs to be sequenced. Here's a different
approach:

    posixWrite : {r}(Fd, Arr(U8)@r) -> () with {IO}
    arrayWrite : {r,a}(MutArr(a)@r, S32, a) -> () with {Write(r)}

Maybe use something shorter than the `with` keyword:

    posixWrite : {r}(Fd, Arr(U8)@r) -> ()+{IO}
    arrayWrite : {r,a}(MutArr(a)@r, S32, a) -> ()+{Write(r)}

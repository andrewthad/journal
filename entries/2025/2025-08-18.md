# Merge Operation With Bounds Checked Arithmetic

For context, I've been thinking lately about what kinds of bounds-checked
operations can be done without full dependent types. For many array operations,
it is sufficient to have a `Fin` type. But not all of them. Let's consider
the "merge" operation, which takes two sorted arrays as arguments and returns
a sorted array with all of the elements from either argument. There are two
flavors of this:

1. Duplicates are preserved. This means that the length of the result array
   is the sum of the lengths of the two argument arrays.
2. Duplicates are removed. This means that the length of the result array
   is less than or equal to the sum of the lengths of the argument arrays.

# Flavor 1

How can flavor 1 be handled with `Fin`? First, let's think about how this
would be described with full DT. The recursive function would have a type
like this:

    step : (offA : Nat) -> (offB : Nat) -> (offDst : Nat)
        -> (offA < lenA) -> (offB < lenB) -> (offDst = offA + offB)
        -> Array (lenA + lenB) S64

Most of the time, when we enumerate the elements of an array, we don't need
any knowledge of the candidate index at the beginning of a step. This is
because we can test to see that it is in bounds. However, merging requires
tracking two indices (into different arrays), and it's foolish to check
them both at the beginning of each step. Only one of them is incremented
on each step. (There is a final operation at the end where all remaining
elements from one array are copied into the result array.)

Here's one way to do this with `Fin` instead:

    step : Fin lenA -> Fin lenB -> Array (lenA + lenB) S64

What about `offDst`? We don't need it because it can be recomputed on demand
by adding the two finite naturals. There is still a question of how this
impacts performance, and I'm not sure about that. It might be better, or worse,
or the same.

# Flavor 2

Flavor 2 is more difficult. First, with DT:

    step : (offA : Nat) -> (offB : Nat) -> (offDst : Nat)
        -> (offA < lenA) -> (offB < lenB) -> (offDst <= offA + offB)
        -> Array ? S64

The length of the output array is no longer known. There is an upper bound
on it though, `lenA + lenB`. The more important difference is that `offDst`
is no longer the sum `offA + offB`. It must be tracked separately and cannot
be materialized on demand.

There is no way to do this with `Fin` because we cannot represent the
relationship between the source indices and the destination index. At the
end of each step, it should be possible to increment one of the source
indices (the one corresponding to whichever source array was used) and
the destination index. And then we need to check that everything is still
in bounds. With DT, we only need to perform one comparison (test that
`offA + 1 < lenA`), and then we have all of the information that we need.

Anyway, I'm not going to make any progress on this. It's just a dead end.

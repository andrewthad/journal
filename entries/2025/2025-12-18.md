# Second-Class Values vs Region Annotations

I was thinking about this again after writing about it yesterday. If we don't
do second-class values, the type of `map` needs to look like this:

    map      : {r,s,a,b}({p}(Ref(a)@p) => b, Array(a)@r) -> Array(b)@s +{Alloc s}
    indexRef : {r,a}(Array(a)@r, S32) -> Ref(a)@r

This suggests that a `Ref` to a struct would probably end up needing to have
a duplicated annotation. I looked at the readme for the Sixten programming
language. Sixten has a special `boxed` keyword that causes certain types
to be pointers even when not wrapped in the `Ptr` type. I prefer uniformity
to that approach, mostly because it helps us get more use out of functions
specialized to work on `Ref` types. I think that the problems that I am running
into are because I want to be able to do both of these:

    Ref(S32)@r
    Ref(Person@r)@r

An overloaded shorthand is probably the best option:

    Ptr(S32)@r
    Ptr(Person)@r
    Ptr(Person@r)@r

The second two forms are the same, but the last one is canonical. If the
argument to `Ptr` has kind `Struct` instead of kind `Type`, it needs to
copy its region annotation over to the argument.

# Unconvention Ways to Prevent Region Escape

The usual way that people write the type of `withRegion` is this:

    withRegion : {a}({r}() -> a +{Alloc(r)}) -> a

This uses universal quantification to prevent escape. But there are other
ways to do this:

    withRegion : {r,a | all_regions_below(a,r)}(() -> a +{Alloc(r+1)}) -> a

Here, we don't need universal quantification, but we do need a constraint.
We have to be able to say "the type a must not refer to regions that are
greater than r". This is an unconventional approach. One strange drawback
to this is that we have to pass an `r` to any function that wants to
allocate into a region, even if the function does not need to touch any
existing data.

I'm not convinced that this is worth it.

# Different Syntax for Effects

I wonder if it makes more sense to have effects earlier in the type signature.
I like to see the return type at the end of the line, and when the effect is
at the end of the line, this information gets obscured.

What about this instead:

    singleton : {r,a}[+r](a) -> Map a

This is nicer to read. Let's try it with `map`:

    map : {r,s,a,b}[+s]({p}(Ref(a)@p) => b, Array(a)@r) -> Array(b)@s

It's a little better. This is still a pain to read. Here it is with
a shorthand for `Ref`:

    map : {r,s,a,b}[+s]({p}(*a@p) => b, Array(a)@r) -> Array(b)@s

Let's see what this would look like when modifying a map in place:

    update : {r,a}({p}(MutRef(a)@p) -> (), Map(a)@r) -> ()

I don't like these little spurious universally quantified lifetime variables
in the callback. I want the signatures to look like this:

    map    : {r,s,a,b}[+s](*a@r => b, Array(a)@r) -> Array(b)@s
    update : {r,a}(&a@r -> (), Map(a)@r) -> ()

This signatures are more correct since they make it possible to pass a closure
as an argument. (I started using ampersand for `MutRef`.) Let's try a few more
of these:

    reverse    : {r,s,a}[+s]. Array(a)@r -> Array(a)@s
    replicate  : {r,a}[+r]. (S32, a) -> MutArray(a)@r
    write      : {r,a}. (MutArray(a)@r, S32, a) -> ()
    mapInPlace : {r,a}. (&a@r -> (), MutArray(a)@r) -> ()
    traverse   : {r,s,e,a,b}[+s,e]. ([e]. *a@r => b, Array(a)@r) -> Array(b)@s

Several things to notice:

1. The big arrow is hardly needed. It's only going to show up when populating
   an array from scratch (without a previous value present). It would be nice
   if there were a way to get rid of this.
2. I've stopped tracking mutation as an effect, but I might need to add it back.
   For something like `mapInPlace`, we cannot let the argument function modify
   an arbitrary value in region `r` because the mutable map itself lives in
   region `r`. And then the behavior ends up depending on the traversal order.
3. I've stopped putting parentheses around the function arguments when there
   is only one argument. I think this reads better.

We could try improving `mapInPlace`:

    // Applied to a region, the ampersand refers to the mutation effect
    mapInPlace : {r,a}[&r]. ({s}[&s]. &a@s -> (), MutArray(a)@r) -> ()

This lets the user mutate the element itself in the function but not
the array. However, even this does not really work. If the elements can
refer to the array that contains them, this would still let us modify
the array in the argument function.

To me, what this indicates is that it makes more sense to just commit
to an iteration order. It's not a good idea to map over any kind of mutable
collection and modify the collection in the element-modifying function.
However, given that it's not possible to prohibit this, I think it would
be prudent to at least make the behavior of it well defined. For arrays,
this is easy. For other kinds of containers, I'm less sure. You would need
to be certain that by the time the callback was invoked, the data structure
was in a valid (and well defined) state. Which I think is typically something
that can be done. So maybe we want this:

    mapInPlace : {r,a}[&r]. ([&r]. &a@r -> (), MutArray(a)@r) -> ()

The best thing about tracking mutation like this is that we can ask for
functions that do not mutate things, and for those functions, we get nice
guarantees like "calling this twice with the same arguments should give me
the same result each time". And it's good to track mutation per region
(rather than just having one big "mutate" effect) because this makes it
possible to use `withRegion` as a boundary to erase the mutation effect.
If we couldn't do that, the mutation effect would just bubble up forever.

# Effect Polymorphism and Separate Compilation

This is still a pain point for me. I'm not sure how to do this.
Especially with some of the array functions, it's very useful to be
able to traverse arrays effectfully. However, the different effects
all mess with calling conventions pretty badly. Some effects, like
mutation, are completely erased at runtime. Others, like allocation,
appear as a function argument. And others, like parsing, appear as
both an argument and as a returned value.

I can probably just specialize the functions that I really care
about though. That's probably enough for the short term.

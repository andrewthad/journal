# Type At Region

Region type systems have two different kinds of types. The system looks like
this:

    @ : Boxed -> Region -> Type
    Person   : Boxed
    Person@r : Type

Only `Person@r` is a "ground type". Once we start to add higher-kinded types
to the mix, some strange things happen. What should the type of `List` be?
We probably want this:

    List        : Type -> Boxed
    List(U64)@r : Type

For this to work, we need a way for the types of the fields of `Cons` to
reference this region. I think that it's possible to do this.

Here's a weird case I've come across. Imagine the type of a catenable builder
that is used to glue arrays together. In a system without any regions, it
would look like this:

    data Builder a
      | Elements (Array a)
      | Concatenate (Array (Builder a))

It makes sense to unbox this type. All of the data constructors have payloads
that are the same size, and the payloads are small. We don't want these 16-byte
data constructors on the heap. We want them on the stack (or in registers or
inlined into other data constructors). What's strange about this is that the
region annotation only really has the "at" treatment on the arrays. So the
region variant of this type is:

    data Builder a r
      | Elements Array(a)@r
      | Concatenate Array(Builder(a,r))@r

But this means that a user would end up working with `List` and `Builder`
in syntactically different ways. The user would have to write `List(U8)@r`
and `Builder(U8,r)`. This is confusing. A user of `Builder` shouldn't have
to think about that fact that the data constructors are not allocated
on the heap.

Here's an idea to improve the user experience. We could make the builder
look more like a boxed type even though it isn't boxed. A user would write
`Builder(a)@r` to talk about builders, but the user would still allocate
the builder without a region handle:

    fromElements : Array(a)@r -> Builder(a)@r
    cons         : Handle(r) -> a -> List(a)@r -> List(a)@r

Another idea is to move the region annotation to the type constructor:

    RegCon       : Kind -> Kind
    Array        : RegCon (Type -> Type) 
    @            : RegCon f -> Region -> f
    Array@r      : Type -> Type
    Array@r(U64) : Type

I'm not sure if there are any advantages to this arrangement. We could
do something much more simple:

    Array   : Region -> Type -> Type
    @       : (Region -> k) -> Region -> k  (synonym for type application)
    Array@r : Type -> Type

What's happening here is that we get rid of the kind `Boxed` entirely.
We might be able to go further and get rid of `@` as well. I'm not sure
that I like this though. We really a way to indicate that a certain region
type parameter is the region that the objects are allocated into.

I think I can see what I want to do. I need to change the kind `Boxed` to
use a different name. Maybe something like `Untethered`. Then we have:

    @ : Untethered -> Region -> Type

Untethered types are just types that need to be associated with a region
to be useable. All heap-allocated type must be untethered. Stack-allocated
types can be untethered, but they do not have to be. Consider a simple
stack-allocated type:

    struct Point = { x : S64, y : S64 }

This should have kind `Type`. We don't need to associate it with a region.
However, the `Builder` type from earlier needs a region:

    struct Builder(a)@r
      | Elements Array(a)@r
      | Concatenate Array(Builder(a)@r)@r

# Other Recursive Structs

Let's see how many other places the need for recursive structs arises. What
about an HTML node type:

    struct Node@r
      | Text
          content : Array(U8)@r
      | Element
          tag        : Array(U8)@r
          attributes : Array(Member)@r
          children   : Array(Node@r)@r

Nope, that would unboxed to 6 64-bit words. That's no good. What about
B trees:

    struct BTree(a)@r
      | Leaf
          keys : Array(Key)@r
          vals : Array(a)@r
      | Branch
          keys : Array(Key)@r
          children : Array(BTree(a)@r)@r

If all of the array lengths are fixed, this works out pretty well. For an
array with fixed length, it's not necessary to store the length, so we
just need 2 64-bit words. However, there is some difficulty with packing
the tag into this. There's a different way to do this though:

    struct BTree(a)@r
      | Leaf Array(Key,a)@r
      | Branch Array(Key, BTree(a)@r)@r

This strategy puts tuples in the arrays. But this is no good because the
size and alignment of `(Key,a)` are unknown. We really need to be able
to unpack the arrays into the type:

    boxed BTree(a)@r
      | Leaf
          keys : unpacked Vector(8, Key)@r
          vals : unpacked Vector(8, a)@r
      | Branch
          keys : unpacked Vector(8, Key)@r
          children : unpacked Vector(9, BTree(a)@r)@r

For immutable B-Trees, this doesn't work. I've never figured out a way
to initialize them. (It requires borrowing the vector field and somehow
ending the borrow when you're done writing all of the elements.) However,
this works fine if all of the data is mutable. And that's the case that
I actually care about.

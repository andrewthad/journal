# RC vs Tracing

I've been thinking about what memory management strategy makes the most sense
to layer on top of regions. I'm comparing RC against tracing (tracing refers
to both mark-and-sweep collectors and moving collectors). Here are some
thoughts about the options:

* RC has the advantage of promptness. Under RC, a gigantic region kept alive
  by a packed reference to it will be freed the moment that the object holding
  that reference goes out of scope.
* All stack references to regions are handled promptly regardless of which
  strategy is chosen.
* Both strategies require some kind of program analysis to improve performance
  but RC relies on this more than tracing does. In particular, RC benefits
  greatly from a analysis that elides increment-then-decrement patterns.
  Tracing strategies can avoid saving values to the stack (or the shadow stack)
  if the lifetime of that value does not cross a GC safepoint. This is less
  important for performance, and I think it's easier to perform simple versions
  of this analysis. For example, if a function doesn't allocate, it trivially
  has no safe points.
* Tracing does not require space to store reference counts.
* RC has abysmal performance when cloning an array of objects. A large number
  of counters must be updated at the same time. Tracing strategies do not
  have this problem.
* Tracing works much better with intensional polymorphism. This is really big
  deal. It means that a polymorphic function that does something simple like
  copying a value (with an abstract type) from object A to object B does not
  need to check to see if it's a reference-counted type.

Tracing seems like the winner. The worst thing about it is that it's possible
to accidentally keep a region in memory for a much longer time than we should.
I'm not sure if there is a way to improve this. We could perform GC more often,
which would help us reclaim memory faster. But all of that tracing has a cost.
Possibly, the solution is just "minimize use of the GC". I know that sounds
silly, but it would help. Every object that the GC has to manage is something
that will have to be traced every time GC is performed. If there are fewer
objects managed by GC, tracing is faster, and it can be performed more often.
Some objects really do have dynamic lifetimes, but many do not.

The choice between mark-and-sweep (nonmoving) and a moving collector seems
clear: mark-and-sweep. Moving collectors have no visibility into objects that
have gone out of scope, but we need this visibility because packed regions
are reference counted.

# CPS and Linear Types Review

On 2025-08-12, I wrote about a system that uses a big arrow, syntactically,
for CPS. It works like this:

    new    : (Int, a) => MutableArray a {1}
    write  : (MutableArray a {1}, Int, a) -> MutableArray a
    freeze : MutableArray a {1} => Array a {*}
    run    : (Unit {*} => b {*}) {1} -> b

The ordinary arrow does not have a linearity annotation on the RHS. That's
consistent with the most common presentations of linear types. CPS is also
well understood. The only difference is the special syntax for it. On top of
these primitives, it's possible to build a function for creating a new
immutable array and assigning its elements with an arbitrary program:

    create : (Int, a, MutableArray a {1} => MutableArray a {1}) {1} -> Array a
    create(n, initial, f) = run:
      arr0 <- new(n,initial)
      arr1 <- f arr0
      freeze(arr1)

For this to work, we really do need `run` to be a primitive. When lowered,
it's a no-op. However, there is not an implementation of it that can be
safely inlined into programs. Forcing the return value to have unrestricted
use is critical. The Linear Haskell paper accomplishes the same thing with
with the `Unrestricted` type. I prefer my approach because you end up needing
some kind of syntactic sugar for CPS either way.

# CPS, Second Class Types, Stack Allocation

It would be really nice to have a way, in the source language, to say "allocate
this object on the stack". Nothing with a variable size, and the total number
of stack allocations should be fixed. That is, we should not be able to stack
allocate inside a recursive join point. What about this:

    withFooOnStack : (forall (s : Region). Foo {2} @s -> a) -> a

The annotation "2" means that the value is second class. This alone prohibits
it from escaping. This works, but the syntax is unpleasant. Let's try improving
this with CPS:

    withFooOnStack2 : () => (exists (s : Region). Foo {2} @s)

CPS gives us a way to put class annotations on a result. We need to prevent
user-defined functions from returning second-class values. Only builtins
(or staged functions) are allowed to do this. We do not need to do anything
to prevent the region from escaping. It is not possible to pack a second-class
value, so there is no way to do this. Also, notably, there is no handle to
the region. So it is not possible to allocate anything else into it.

# Region Subtyping

This is something I still need to figure out. It should be possible for
a younger region to pretend any object in an older region is a part of it.
We need to be pretty precise about this though. If we pack the younger
region, we pack the older region with it. I want this to be both convenient
to use and convenient to express in a System-F-style type system. That's
what I'm having trouble with.

I have an entry from 2024-02-21 that's a little helpful (not a ton). I was
thinking, at the time of treating stack frames as numbers, which makes it
possible to do a kind of subtyping where `Object@s` can be upcasted to
`Object@(s+1)`. Here's an idea about how this could be adapted:

    {r}, (rhnd : Region r) = region.root
    {s}, (shnd : Region (r + s)) = region.child{r}

The second region is not `s`. It is `r+s`, a region that subsumes region `r`.
Now subtyping will just work, and everything should be fine.

# Atom vs Expression vs Program

When lowering to C, it's possible to compose expressions (anything that
doesn't need to bind a value for reuse) to form a larger expression.
Full ANF distinguishes programs from atoms, but I think it may be nice
to do something a little more fine grained. It's always possible to go back
and redo this later when building a native code generator instead of lowering
to C.

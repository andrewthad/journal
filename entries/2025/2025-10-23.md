# Regions as Natural Numbers (Again)

## Debruijn Indices

It does not seem like this is a good idea. If we do debruijn indices, we have
to rewrite the types of everything in the context whenever the `withRegion`
primop opens up a region. The current region would be zero. Statically defined
data would be in region infinity, and anything immutable could be casted to a
region with a lower number. This has several cool properties:

1. No need to invent names for region type variables (in simple cases)
2. Region subtyping is simple since it just compare numbers for equality
3. Everything can trivially be upcasted to the topmost region since it
   has the number zero.

But rewriting all of the types in the environment is awful. I've never seen
an extension of System F that does this. This interaction with polykinds
might be bad.

## Debruijn Levels

Let's try it with debruijn levels instead. This does not have the same
issue with retyping the context, which is good. However, every function has
to track the current level that it is called at. So if the current level is
`n`, then the first call to `withRegion` opens up level `n+1`. We also have
to be able to track which regions we can allocate into, but that might be
done with the effect system. I've got a little prior thought in the entry
from 2025-09-16.

With an effect system, I think it should be possible to just track the
topmost region with an effect. You need something like this:

    with : âˆ€(n : Nat). (Unit =>{n+1} a) =>{n} a

But we have no way to prevent anything defined in the new region from escaping.
We really need to prevent that. One solution is to make `with` have a more
magical type that looks into `a` and checks that it does not include anything in
a region that is greater than `n`. I don't like this because it not a thing that
people normally do in extensions of System F.

## Conclusions

I think I have convinced myself (again) that it is not a good idea to try to use
debruijn indices or debruijn levels for regions.

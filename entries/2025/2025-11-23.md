# Parser Namespacing

Trying to figure this out. Just spitballing:

* parse.bin.expect.u8 (expect a specific token)
* parse.bin.expect.array (expect a specific array of tokens)
* parse.bin.one (consume and return a single byte)
* parse.bin.take (take a fixed number of bytes)
* parse.utf8.expect.u8.ascii (expect a specific ascii character)
* parse.utf8.one.ascii (parse a u8 between 0 and 127)
* parse.utf8.many.ascii (zero or more)
* parse.utf8.some.ascii (one or more)
* parse.utf8.take.ascii (take a fixed number of ascii characters)
* parse.utf8.skip.ascii (skip ascii characters, allows zero matches)
* parse.utf8.skip1.ascii (skip ascii characters, must match at least one)
* parse.utf8.(one|many|some|take|skip).alpha (parse a u8 in the class [a-zA-Z])
* parse.utf8.(one|many|some|take|skip).space (posix space class)
* parse.utf8.(one|many|some|take|skip) (characters of a
  designated class, these generalize the other functions)
* parse.utf8.dec.u8 (parse a decimal-encoded u8, ascii not UTF-16)
* parse.utf8.dec.u16
* parse.utf8.dec.u32
* parse.utf8.dec.u64
* parse.utf8.hex.fixed.u8 (parse hex-encoded u8, two characters)
* parse.utf8.hex.fixed.u16 (parse hex-encoded u16, four characters)
* parse.utf8.hex.fixed.u32 (parse hex-encoded u32, eight characters)
* parse.utf8.hex.fixed.u64 (parse hex-encoded u64, 16 characters)

# Parsing HTML

Both html and xml use indefinite-length encodings for attribute lists
and child elements. I need a good way to push elements onto a growable
builder to handle this. I should just build something like this into
the language, probably as an effect.

# Array Builders

There are "big buffer" and "small buffer" approaches to this. I've not
been able to try out either of these, and I'm also not familiar with
any prior work. Array builders are typically not built into a language,
and they usually use a "buffer doubling" strategy. What I would like
to do instead is to have little 16-element chunks (small buffers) that
get linked as the builder is populated, and then at the end we can
work back through the buffer and populate a destination array. This
strategy always performs a copy, even when the array builder contains
just one element.

There's a bit of metadata that is needed to make this work. A part of
the heap must be used only for this purpose (not as ordinary blocks for
allocated data). The buffers must have this metadata: a pointer to the
previous chunk and a boolean indicating their availability (these
could be consolidated into a single field, zero meaning unavailable).

The buffers probably need a fixed size rather than a fixed number of
elements. They should each be 128 bytes (aligned). The availability
metadata should live outside of the buffer. This will make it easier
to scan for additional blocks as they are needed. Alternatively, we
could track availability with a stack of block indexes. Once freed,
a block has its index push back onto the top of the stack. So the
overhead of this ends up being a total of 8 bytes for each buffer:
4 bytes for the possibility of existing in the stack and 4 bytes for
the link to the next buffer. We should zero out the link after a buffer
is consumed just to help catch mistakes.

The copies into the array could all use SIMD and would be very fast.

As the array builder is being constructed, we have to keep track of the
total length somewhere. I think that we will end up with something like
this that get passed around at runtime:

    struct bldrstate {
      char* cursor; // what address we are writing to next (in the buffer)
      char* end;    // The last address at which there is enough space for an element.
                    // This is a lower address than the true "end" of the buffer, but
                    // it is more useful.
      int32_t buf_index; // the index to the current buffer (techincally, could be derived from "end") 
      int32_t count;     // how many elements have been written (across all blocks)
    }

This should get allocated on the stack, and then a pointer to it gets
passed around. Then we just need a function to push an element onto the
end of it:

    void push(struct bldrstate* st, void* element, size_t sz)

This should probably be marked as `inline`, and it should have size-based
specializations. The common path looks like this:

    if(st->cursor <= st->end) {
      __builtin_memcpy(st->cursor, element, sz);
      st->cursor += sz;
    } else {
      ...
    }

Note to self: I've realized that it is difficult to make this work correctly
with `longjmp`-based exceptions. Proper stack unwinding would be required.

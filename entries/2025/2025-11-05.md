# Array Writers With Deterministic Failure

This is an idea I've been pondering on and off for a while now. What if
we take a piece of memory and cut it up into pages (4KB each), and each
the page permissions alternate: writeable page, guard page, writeable page,
etc. (It's also fine to have 3 writeable pages followed by 1 guard page
or 7 writeable pages followed by 1 guard page, any integer 2^n-1 is fine.)

An array builder is initialized with a maximum capacity, and it only has
a "push" operation. It is not possible to read back anything that has been
written to the array builder. The builder is backed by a page (or series
of pages) that is trailed by a guard page. Two possibilities for a user
interface are (1) an effect scoped by a "with" construct and (2) a builder
types that is consumed linearly.

There are two ways for the builder to work. The first one is to always start
at the beginning of writeable memory, working your way toward the guard
page. This makes it possible to use more space that you were supposed to
use. For example, the user might say "I need 200 bytes", and the runtime
might actually let the user write 2500 bytes instead. So there would need
to be a check at the end to make sure that the user did not write too much.
The advantage of this strategy is that, after a small builder completes,
another small builder (allocating into the same region) might be able to
reuse the same page(s). The disadvantage is that it is not sound to
combine this kind of builder with IO. In the case that a writer went
past the end of the requested space, it would not be predictable which
IO action had managed to take effect.

The other way to do this is to start in the middle of the page instead of
at the beginning. So, if the user says "I need 200 bytes", and the backing
page is 4096 bytes, the runtime starts them at position 3896. The advantage
of this strategy is that it can be safely mixed with IO. The disadvantage
is that none of the pages can be reused for multiple arrays. For large
arrays, this does not matter, but for small arrays, it's a big deal. It
would be necessary to memcpy any small array out of the buffer once it
was finalized.

One thing that's neat is that both of these strategies can be used at the
same time. The buffer-filling code doesn't care which strategy is used.
It's only at the edge (the start and the beginning of the array-builder
section) where the difference matters. So the "with" construct could
just choose what to do based on whether or not the IO effect was propogated
though.

Also, the second strategy is easier to implement. It doesn't require
figuring out how much memory is available in each buffer. Every buffer
is just "taken" or "not taken". So this is probably what I should use
to start.

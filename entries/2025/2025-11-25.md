# More Array Builder Strategies

On 2025-11-23, I discussed array builders. There are two other implementation
strategies that I have thought about:

1. All builders share the same memory buffer, and this buffer is used as
   a stack. This works because two builders cannot be active at the same
   time. So, we might be in the middle of building one array, and then
   we start building a different one in the memory immidiately following
   the first one, and it's fine. We cannot push to the first one again
   until we are done with the second one. This strategy works fine with
   exceptions because the `withException` handler just needs to mark the
   current buffer position and restore it when an exception is caught.
2. Going one step further, we could put the builders on the stack (with
   `alloca`). This does not work well because it means that a function
   cannot call another function to help populate a builder.

Strategy 1 is neat, but it has one strange flaw. It's difficult for a
direct-style language to maintain the proper invariant. Here's one way
this could be done in a direct-style language. Every function must accept
an additional linear argument. This argument is a handle to the thread's
builder. It's only possible to start building a new array by consuming
the handle. You get the old handle back when you finalize (copy) the
completed array. It would look like this:

    new      : Handle n {1} -> (Handle{1} (n+1), Builder (n+1) a {1})
    push     : Handle n {1} -> Builder n a {1} -> a -> Builder n a {1}
    finalize : Handle (n+1) {1} -> Builder (n+1) a {1} -> (Handle n {1}, Array a)

So, the old handle becomes unavailable, and the only way to recover it is
to finalize the new builder.

This is similar to how direct-style regions work. Interestingly, we do not
need existential quantification. Here is the reason for this difference.
Direct-style regions allow the user to create adjacent child regions, both
children of the same parent that are unequal to one another. The cannot both
be `r+1`, so they must be `r+a` and `r+b`, for some unknown `a` and `b`.
There are other reasons though. Exisentially packed regions should not
have a parent region, so they need an existentially quantified region variable.

I am reminded while thinking about this that exceptions and linear types
can work together fine. The `throw` function just needs to return all of
the linear stuff. Which means that the corresponding `catch` needs to be
prepared to receive it. This is doable. It's just awful.

# GCC Flag

I learned about this gcc flag: `-fcf-protection=none`. This makes
`__builtin_setjmp` and `__builtin_longjmp` require a lot less boilerplate.

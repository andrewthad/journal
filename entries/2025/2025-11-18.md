# Arrays and Strings and Paths

## Prior Art in Rust

I looked at Rust's standard library for inspiration. It has several types:

* `Vec<u8>`: any byte sequence
* `String`: UTF-8 encoded text
* `OsString`: on linux, any byte sequence (should not contain interior NUL,
  but this is not actually enforced)
* `PathBuf`: A wrapper around `OsString` with additional invariants.

There are owned and borrowed variants of each of these. The borrowing stuff,
I'm not interested in. I care about the semantics and the invariants of these
types.

On Windows, `OsString` is a more meaningful abstraction because of the WTF-8
stuff used to deal with platform strings. But on Linux, `OsString` is
basically the same thing as `Vec<u8>`. There is no guarantee that the byte
sequence in the UTF-8 encoding of anything. The user can call `to_str` or
`into_string` to try to create a string from it. Additionally, there is
no guarantee that interior NUL is absent. We can see that this guarantee
is missing because of the this implementation:

    impl From<String> for OsString

Fundamentally, we are not dealing with anything different than `Vec<u8>`
when we use `OsString`. There are a bunch of methods work working specifically
with PathBuf and with OsString. That's the main utility.

It's not hard to find people complaining about this on the Internet. The
argument in favor of Rust's scheme for paths and os strings is that you
have to be more explicit about what type of data you are dealing with. And
the argument against it is that this explicitness (in the form of little
no-op casts between types) is annoying to have to do.

## Prior Art in Golang

Golang's approach contrasts nicely with rust's. In golang, all file paths
are just strings. This means that, when dealing with paths that are not
UTF-8 encoded strings, the standard library does weird and unpredictable
things. Advantage: more simple and easier to use in the extremely common
case. Disadvantage: broken in the uncommon case. As as example of where
this would cause a problem, consider a general purpose file syncing tool
that should really be able to handle any file name.

To see examples of Golang's approach, note that `DirEntry` has a string
as the name. Also, both `fs.Open` and `os.Open` accept a string as the
file name.

(Unrelatedly, browsing this part of Golang's standard library reminds me
that I can't stand how abstract everything is. FS, File, FileInfo, etc.
I guess maybe there's someone out there who is able to write code that
works on both a Unix filesystem and on S3 because of all of this.)

## My Own Thoughts

I want three variants of all the UNIX stuff that deals with names (or
"OS strings"):

* An OS string is a sequence of bytes (`Arr(U8)`)
* An OS string is UTF-8 encoded text (`Str`)
* An OS string is an ASCII subset (`Arr(PrintableAsciiChar)`)

It's really just the first and the last one that I need for myself though, so
I could probably start without the `Str` variants. There are a few things
to think through:

* Subtyping is important. It would be nice to have different "directory entry"
  types with appropriate subtype relationships so that I could upcast anything
  to the `Arr(U8)` version of a directory entry.
* Subyping is important (again). We only need one function for opening files
  because we should be able to upcast `Str` and arrays of printable ascii chars
  to `Arr(U8)`. Any time a file path appears in argument position, we should
  just accept the most generous type possible.
* What do you do when there is a file with a name that cannot be decoded to
  whatever subset of paths you are accepting? Here are some options: ignore
  the files (just skip over them in a "list directory" function), crash the
  program, return an error code (augmenting posix error codes). For syscalls
  like `readlink`, it's not possible to skip over anything, so the only thing
  that makes sense is returning an error code (or crashing). For syscalls like
  `readdir`, it's not possible to return an error as an individual listing,
  so skipping is the only option.

## Subtyping Again

I've been thinking about how to set up subtyping so that there are only
relationships between types with the same arity. Here's an idea:

    ArrConstraint = set of {Str}
    Arr : {ArrConstraint}(Type) -> UType
    U8  : {U8Constraint} -> Type

Now we have:

    type String = Arr{Str}(U8{})

The trick here is that we want to be able to write `U8` most of the time
to refer to `U8{}` (an unsigned 8-bit integer with no refinements). Same
thing goes for `Arr`. It's might be tricky to actually get that to work,
but I'll worry about that later. Let's see what happens with builders:

    Bldr : {ArrConstraint}(Type) -> UType
    Arr <: Bldr
    type StringBldr = Bldr{Str}(U8)

Pretty neat.

The good thing about this is that it keeps the subtyping rules simple.
The bad thing is that it pushes us in the direction of refinement polymorphism:

    run    : Bldr{c}(a) -> Arr{c}(a)
    append : Bldr{c}(a) -> Bldr{c}(a) -> Bldr{c}(a)

And even this is a stretch. For example, if we added a refinement that
meant "is empty", this would no longer be true. However, since we happen
to control the set of refinements, we can them so that they satisfy laws
that we care about. For example, we could have a `Utf16` constraint (used
with `U16` elements) that meant that the array/builder was UTF-16 encoded
text. We could even have "non-empty" as a refinement. The utility of
something like that is a little dubious, but we get a few nice things
from it:

    encodeDecimal : U64 -> Str{NotEmpty}

Another ideas is strings that match a regex. An issue with this is
that most operations on strings cannot actually exploit this property.
Anyway, here's the heart of the original problem. I want all of these
relationships:

    String <: Bytes
    AsciiString <: String
    AsciiString <: Bytes (implied by transitivity)

The `String` type has to be an array for this to work nicely.

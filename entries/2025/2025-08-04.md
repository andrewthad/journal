# Regions Without Packing

## Difficulties

The existential packing of regions leads to implementation difficulties.
It is necessary to reference count any packed region so that it can be
freed at the right moment. I am aware of at these difficulties:

* It is difficult to represent an object packed together with a region
  without using more than 64 bits. All the ways that I have thought of
  would make the RC operations unacceptably slow.
* Any intensional polymorphism that is able to handle objects packed with
  regions must have a code path for RC operations (for types where that
  is necessary). In many cases, polymorphic functions are never applied
  to boxed arguments.
* Existential packing results in a kind of decision paralysis when designing
  APIs. There are often two or more possible type signatures for a function.

## Idea

What about simply not supporting the existential packing of objects with their
backing regions? This solves all of the problems listed above, but it introduces
some new problems. These problems are all a result of regions being organized
as a stack (FIFO), with no way for a younger region to outlive an older region:

1. It is impossible to cheaply pass messages between threads.
2. Sharing becomes more difficult and requires more thought.
3. Persistent data structures do not work as well since the no-longer-referenced
   memory lingers until the entire region is dead.
4. Small simple programs are more difficult to write. It is no longer possible
   to call a function that returns boxed data without first allocating a region
   to pass to that function.

Problem 1 does not have a good solution. Passing messages between threads
with channels is just not going to be possible. There are certain forms
of structured concurrency that are still fine. Passing primitive
values between threads is fine. And there are certain forms of structured
concurrency that would work. For example, it should be possible to fork
several threads, each of which return boxed object in a fresh, and then block
until they have all finished and combine the regions.

Problems 2 and 3 are similar and are also fundamental. Most functional
programming languages support programs that walk over a data structure and
reuse arbitrary parts of it. It would not be possible to write the same
program in the same way in this language. If a function might update a small
part of a data structure, it would need to reallocate the whole thing.
I'm not sure whether this would typically end up improving performance
or making it worse. But, the ergonomics of it would be worse.

Problem 4 is the one that I am most hopeful about. There are several ways to
improve this (ordering these by complexity):

* Syntactic sugar for function declarations that assumes that the regions
  for all arguments are distinct.
* Region inferrence when applying a function to arguments.
* Eliding region handles as implicit arguments when possible.
* Staged programming. Building strings can be a nasty business even in
  languages with good ergonomics. A staged implementation of format strings 
  could compile to "allocate region, paste into buffer, write to file
  descriptor, deallocate region".
* A system that can infer when a region needs to be allocated. Suppose
  that there is a variant of POSIX `read` that allocates a byte array
  and reads bytes into it, returning the freshly allocated array. Many
  invocations of this function would allocate a region region right
  before calling it. I think that it might be possible to infer this
  so that the user doesn't have to write it out by hand. We might want
  to be able to do the same with any function that takes a region-handle
  argument and returns a result that is allocated into it. The rule for
  this would be that the object must not escape the function whose body
  is being written. If it was going to escape, the function would need
  to take a handle as an argument, and that handle would need to be
  passed to the function when it was called.

## Wacky Idea

Here's another idea that I haven't considered this before. What if objects
could be packed with regions, but the resulting type was not first class?
Instantiate a polymorphic function with a type like this would be prohibited.
Going a step further, even fields in boxed objects could not be of these
types. So anything with a type like this would be directly associated with
a binder. The expressive power of these is very low, but this might be
useful for a repl.

## Subregion Interaction With Mutability

Mutability and subtyping do not play together nicely. I believe that subregions
are an important feature for any language with regions. It should be possible
to allocate a new region and then pretend that existing objects (in older
regions) were part of that region. Mostly, this works fine. However, we cannot
do this for the argument type of a mutable array. Pretending that the mutable
array has elements in the new region would let us write elements to the array
that would become dangling pointers after the region was deallocated.

The solution is to track whether type arguments are covariant or invariant.
I do not like this solution, but it's the only thing that makes sense. OCaml
has this feature (it also lets you indicate contravariance).

My short-term plan is to just wait as long as I can to implement mutability.
I can write a lot of interesting programs without it.

## Doubled Region Type Argument for Recursive Types

I've noticed this problem before, but I'll write it out again. Suppose we
have a cons list, and the entire spine should live in the same region:

    data List r a
      | Cons a (List r a)@r
      | Nil

This happens for every recursive type. The implementation of the language
is more simple this way. But the ergonomics are terrible. We should not
have to write `(List r a)@r`. We should be writing `(List a)@r` (or maybe
`List@r a`).

One solution is to require all boxed types to take a region as their first
argument. This makes it impossible to abstract over boxed types. However,
if I'm dumping existential quantification and packed objects, I may not
even need this. But it still feels like the wrong thing to do. Maybe there
is something more simple:

    data List a {r=@}
      | Cons a (List a)@r
      | Nil

The trick here is that the second argument is defaulted, but this defaulting
only happens if the `At` operator is applied directly to the boxed type. This
works, and it keeps things simple.

One minor question here is whether the region argument should come first or
last. I'm not sure.

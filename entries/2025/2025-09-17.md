# Scoping Mutation

I want to have mutation in my language, but I don't need to be able to
in-place freeze mutable objects. It's only really arrays that need to get
frozen, so there are going to be two different kinds of mutable arrays.
One of them will use linearity or uniqueness, and the other will use
something like GHC's ST.

The bad thing about ST is that it introduces a phantom type that we have
to keep track of, and I don't like that. In the system I'm working on,
boxed objects already have an annotation, but it's a region annotation.
I'm thinking about reusing the region annotation to track mutation as
well. Here's an example:

    new    : (Handle(r)) -> (MutMap(a)@r) +mut(r)
    insert : (Handle(r), MutMap(a)@r, Key, a) -> () +mut(r)
    lookup : (MutMap(a)@r, Key) -> (Option(a)) +mut(r)

The arrow is annotated with the effect (`mut(r)`). We just need a way to
prevent escape:

    run : ({r : Region}(Handle(r), a) -> b +mut(r)) -> a -> b

Even if the user existentially packs something from the region (so that it
escapes), this is still sound. There's no way to recover the mutation effect
later because it can only be created for fresh regions. It might be useful
to have a similar primitive for ordinary region use. It could be helpful for
a user to see visually that a region they were creating had a lifetime bounded
in a specific way. In a case like that, it would be nice to actually have some
kind of guarantee that the region could not be packed.

# Packing Regions

What if the packing of regions was disallowed by default? What if there were
different primitives to create packed regions and regions with lexically scoped
lifetimes? It would look like this:

    // Creates a region and deallocates it when finished
    withRegion : ({r}(Handle(r)) -> a) -> a
    // Creates a region and packs it up with the returned object
    packRegion : ({r}(Handle(r)) -> a@r) -> Packed(a)
    withPacked : (({r}(a@r) -> b), Packed a) -> b

I like this because it requires less analysis to lower it during compilation.
For this to work correctly, we really need to make sure that the handle to a
region cannot end up stored in a data type. This could be accomplished by
making it a second-class value.

This disadvantage of this strategy is that it's not possible to jump to a
join point from inside of `withRegion`. I think that's ok. The solution is
to just define the join point inside of `withRegion`.

# Refining Data Types

I've been thinking about a few different options how to refine data types.
Here are the main things to consider:

* It is good for types to be simple.
* It is good for expressions to synthesize the most refined version of
  a type that they possibly can.

## Old Idea: Structural Refinements

In the past, I've thought about having ADTs support refinement of all
fields. For example:

    type Foo = record {x : Int, y : Int, z : Int}
    foo = Foo{x = 1, y = 2, z = 5}
    foo : (Foo | .x=1, .y=2, .z=5)

This looks appealing on simple types, but it starts to fall apart when
we introduce recursive types. You end up with shallow refinements and
deep refinements. There's probably some kind of regex-like construct
that can describe refinements at paths (and supports union and intersection
of refinements), but the syntax is unpleasant. It's unpleasant because
the refinements are structural instead of nominal. Structural types have
nice theoretical properties, but they are so unpleasant to use that few
languages offer them.

## Other Idea: Nominal Subtypes

Another way to approach this is to have the user explicitly define
all the subtypes that they are interested in:

    type Foo = record {x : Int, y : Int, z : Int}
    type FooPositive <: Foo = record {x : (Int | >= 0), y : (Int | >= 0), z : (Int | >= 0)}

The user has to explicitly list any supertypes when defining a subtype.
And the fields all have to agree. It's much easier to handle recursively
defined types this way. Also, it's possible to omit data constructors
from subtypes to indicate that they are not available. For example:

    type Map v
      | Bin Map Key Map
      | Tip Key v
      | Empty
    type NonEmptyMap <: Map
      | Bin Map Key Map
      | Tip Key v

One drawback of this approach is that, when constructing data, you must
specify which variant you are making. It is not inferred since there is
no principal type.

## Example

I would like to have several distinctions when working with HTML:

* Producer (uses arrays) vs Consumer (uses builders)
* Unrestricted character set vs ASCII vs ASCII without escape sequences

The product of these gives us six different HTML types. I don't really
want six types though. I want something like this:

    refinement Charset      = Unicode | Ascii | Micro
    refinement Catenability = Arr | Bldr
    interpretForTag  : Charset -> IntegerPredicate
    interpretForText : Charset -> IntegerPredicate
    type Html{ref0 = Charset, ref1 = Catenability}
      | Element
          tag        : Seq{Utf8,ref1}(U8{interpretForTag ref0})
          attributes : Seq{ref1}(Attribute{ref0,ref1})
          children   : Seq{ref1}(Html{ref0,ref1})
      | Text
          content : Seq{Utf8,ref1}(U8{interpretForText ref0})

Having written it out, I feel like this is so complicated that it is
not worth it. Just defining all of the types separately is not that bad.
The difficulty is deciding on a naming convention. Maybe these names:

* `Html`
* `HtmlBldr`
* `HtmlAscii`
* `HtmlAsciiBldr`
* `HtmlPlain`
* `HtmlPlainBldr`

Also, I think it should be possible to handle arrays and strings like this:

    Arr : Type -> Boxed
    Str : Type -> Type0 (note: element should always be U8)
    Str <: Arr
    ArrBldr : Type -> Boxed
    StrBldr : Type -> Type0 (note: element should always be U8)
    StrBldr <: Arr
    type String = Str(U8)

# Undefined Behavior

I have changed my mind on some types of undefined behavior. The worst kinds
of undefined behaviors are ones where a user is likely to come to expect a
certain behavior. I now think that writing to an array without a full proof
that the index is in bounds is fine. Users do not come to expect that an
out-of-bounds writes are ok. At least, they usually do not. Sometimes, in
runtimes that let users index past the end of an array of primitive values,
users begin to expect that this is safe. Hopefully, they assume that the
element returned is garbage.

# Array Writers

I'm trying to think of a nice API for an array writer. The use case I'm
thinking of is that the exact number of elements is known in advance.
Every push should just write and increment a pointer, returning a new
pointer. The writer is threaded through the program linearly. But how
do we get back to the beginning of the array at the end? We could do
something like this:

    new    : Unit => (s : Token, Writer s {1}, Base s {1})
    push   : (Writer s {1}, Element) -> Writer s
    finish : (Writer s {1}, Base s {1}) => Array {*}

I hate inventing a token type to make this work though. But if we do not
tag the writer and the base, it becomes possible to pair a writer with the
wrong base. We need something better. With higher-order functions, we
could do a little better:

    withWriter : (Writer {1} -> Writer {1}) -> Array

Now we don't need to keep track of the base because `withWriter` does that
under the hood. But having a syntactic construct for this is a cumbersome
solution.

Here's another idea. What if we just use the first strategy but without
the tags. The base could be represented by a combination of a pointer and
a length. The `finish` function would check that the writer was equal to
the base plus the length, crashing the program unrecoverably if this equality
did not hold. This strategy makes the behavior of mixing writers well defined.
It also crashes the program  in situations where the writer is not completely
filled by the user (which is good).

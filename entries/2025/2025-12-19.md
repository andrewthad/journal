# Types Without a Known Size

There's a weird quirk of the Ptr/Ref strategy that I described on 2025-12-15
and 2025-12-17. There are struct types like Person and Vec3 that have a
known size. So stuff like this makes sense:

* Pointer: `Ref(Vec3)@r` 
* Array: `Array(Vec3)@r`

But consider a type like `Expr`, which has several variable-width data
constructors:

* Pointer: `Ref(Expr@r)@r` 
* Array: `Array(Expr@r)@r` (bad)
* Array: `Array(Ref(Expr@r)@r)@r` (good)

The second form should be ill kinded. We cannot have an array of unboxed
`Expr` because they do not have a fixed size. This suggests that `Expr`
and `Vec3` should have different kinds. Perhaps something like `Type`
for `Vec3` and something like `UnsizedType` for `Vec3`. And there would be
a subkinding relationship between these. Unsized is the more broad
category. Generally, polymorphic functions would work on types with known
sizes. However, a polymorphic function that specifically expects a `Ref`
might use a type variable with kind `UnsizedType` instead.

The subkind relationship is problematic. Type variables with the unsized
kind do not actually need to be represented at runtime. In theory, if we
need a function of type `{a : Unsized} -> Ptr a -> Ptr a`, we should be able
to pass it a function of type `{a : Type} -> Ptr a -> Ptr a`. That's what
a subkind relationship would imply. However, these functions have different
representations at run time. The first function is unable to touch the
payload itself. It cannot copy it into other data structures because it
does not know its size.

We could take a different approach. I don't like this approach, but I'm
going to write it down anyway. The size could be a separate argument, a
witness to the size of a type. This collapses `Unsized` and `Type` back
into a single kind:

    choosePtr : {a : Type} -> Bool -> Ptr(a)@r -> Ptr(a)@r -> Ptr(a)@r
    singleton : {a : Type} -> Size(a) -> Ptr(a)@? -> List(a)@r

This way, type variables have no representation at run time. I consider this
an improvement. (Region variables also have no representation.) The `Size`
of each type has a single inhabitant. The type `Size(List(S64))` is
uninhabited. This means that we cannot construct a value with the type
`*List(List(S64))@r`, but we can construct a `*List(*List(S64))@r`.

This actually solves another problem that I have encountered before. It's
a problem with arrays. Consider an operation like this:

    indexArrayArray : {a : Type} -> Array(Array(a))@r -> S32 -> Array(a)@r

We do not actually need to know the size of the type to perform this operation.

In a user-facing language, the size argument should be implicit. There's no
reason to pass these around by hand.

Also, this solves another problem. Think about a type like this:

    type WithId(a) = { key : S64, val : a }

Can we put `WithId(Ptr(Person))` in an array? The size is known to be 16 bytes,
so we should be able to do this. We end up needing something like this:

    sizeOfWithId : Size(a) -> Size(WithId(a))

Again, this should be dealt with implicitly. There's only one way to write this
function for each type, and it is determined by the type itself.

# DPS Big Arrow Woes

Here are some problems related to the DPS big arrow that I have noticed:

* It is strange that it only changes the calling convention.
* DPS function can only be used by `array.map` or by a special primitive
  for writing to a field in an object.
* The interaction with parsers is a little strange because parsers already
  imply DPS for a lot of types (but not for all types).

It's possible to accomplish something similar with linear types. Still,
I think that I prefer the big arrow.

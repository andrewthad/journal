# Compound Literals for Constant Data

I learned recently that in C23, we can do this:

    struct foo {int x, y;};
    const struct foo* my_func(int a) {
      const struct foo* z = &(static const struct foo){.x = 1, .y = 2};
      return z;
    }

This is sound, and it is equivalent to doing this:

    struct foo {int x, y;};
    const struct foo top_foo = {.x = 1, .y = 2};
    const struct foo* my_func(int a) {
      const struct foo* z = &top_foo;
      return z;
    }

This is neat because it gives us a way to build constants inside of functions
when lowering to C.

# Adding Refinements to Type Constructors

I added refinements to a system by just having every type constructor
accept an additional (mandatory) refinement argument. This worked really
well. It's surprising how straightforward the change was to make.

# Lower Higher-Order Functions to C

I've been trying to come up with an acceptable way to lower higher-order
functions to C. Here's a strategy:

* Only top-level functions and second-class closures are supported. That is,
  a closure cannot escape a function.
* The lowering of each top-level function is paired with a wrapper. The wrapper
  indirects all arguments behind pointers (`char*` or `void*`), which homogenizes
  the calling convention. The wrapper uses destination-passing style instead
  of returning.

For example, consider a function that increments a 64-bit integer:

    struct array {
      int length;
      char* payload;
    };
    int64_t incr(int64_t x) {
      return x + 1;
    }
    void wrap_incr(char* restrict dst, char* restrict arg) {
      int64_t x = *(int64_t*)arg;
      int64_t result = incr(x);
      __builtin_memcpy(dst, &result, 8);
    }
    struct array map(size_t a, size_t b, void (*func)(char*, char*), struct array xs) {
      struct array result = {.length = xs.length, .payload = malloc(xs.length * b)};
      char* end = xs.payload + (a * xs.length);
      char* output = result.payload;
      for(char* input = xs.payload; input < end; input += a, output += b) {
        (*func)(output, input);
      }
      return result;
    }

The generated assembly for this is not that bad. Here's what I get for `map`
when building with `gcc -S -Os -Wall -fno-stack-protector -fno-omit-frame-pointer -fno-asynchronous-unwind-tables -masm=intel -c ex008.c`:

    map:
        endbr64
        push    rbp
        mov rbp, rsp
        push    r15
        mov r15, rdx
        push    r14
        mov r14, rsi
        push    r13
        mov r13, rdi
        push    r12
        push    rbx
        mov rbx, r8
        sub rsp, 40
        mov QWORD PTR -56[rbp], rcx
        movsx   r12, DWORD PTR -56[rbp]
        mov rdi, r12
        imul    r12, r13
        imul    rdi, rsi
        call    malloc@PLT
        mov rdx, rax
        lea rax, [rbx+r12]
        mov QWORD PTR -64[rbp], rax
        mov r12, rdx
    .L4:
        mov rax, QWORD PTR -64[rbp]
        cmp rbx, rax
        jnb .L8
        mov QWORD PTR -72[rbp], rdx
        mov rsi, rbx
        mov rdi, r12
        add rbx, r13
        call    r15
        add r12, r14
        mov rdx, QWORD PTR -72[rbp]
        jmp .L4
    .L8:
        mov eax, DWORD PTR -56[rbp]
        add rsp, 40
        pop rbx
        pop r12
        pop r13
        pop r14
        pop r15
        pop rbp
        ret

The actual loop (between `L4` and `L8`) looks pretty good.

Interestingly, in this case, I don't think anything would be gained by
having access to AVX512 instructions. We don't use any `memcpy` with
an unknown size, so the operations that index and write from and to the
arrays lower to nice simple loads and stores. We are able to do this
because we wait to dereference the pointers until we are in a context
where we know the actual type of the contents.

In cases where the result will not be immidiately written to a known
memory location, we could pass memory that is backed by the stack instead.
Then we could `memcpy` the result from the stack into the places that
it needs to go.

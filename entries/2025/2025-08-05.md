# Staged Program for Directory Traversal

Every now and then, I have to write a program that processes all the files
in a directory tree. The height of the tree in known, and each layer has
a certain meaning. I would like to be able to do something like this:

    traverse((?<org>.*)/widgets/(?<widget>.*).json){fd}:
      # Here, fd is a file descriptor that has been open in read-only mode
      print(f"Processing widget {widget} belonging to org {org}\n")
      processFile(fd)

Python has something similar to this, `os.walk()`, but it doesn't really
do what I want. I want all of this lumped into one construct:

* Only match file names that follow certain patterns, especially file names
  with certain extensions.
* Handle multiple directory levels and expose the name of each directory name
  to the user.
* Give the user a read-only file descriptor. The user should not have to
  glue all the path pieces together to construct a valid path. The user can
  do this if he or she needs to, but it's not what is typically needed, and
  it's also not immidiately available as an artifact of performing a directory
  traversal.
* Use a regex-like syntax. The notable departure from any kind of standard
  regex is that slash character here is a delimiter that breaks the example
  into three separate regular expressions. And each of this is implicitly
  anchor at the beginning and end. The slash character cannot occur in POSIX
  file names, so this is a natural use for it. It's also worth noting that
  the dot metacharacter should not actually match slashes, but this departure
  from standard regex does not meaningfully affect the results since file names
  cannot contain slashes.

Doing this by hand is tedious, and it's a source of mistakes. That is why
I would rather be able to do it this way.

Syntactically, the tricky part of this is that I want three binders (`org`,
`widget`, `fd`) to be available in the body. I'm not sure what the best
way is to do this. Here's a different way:

    traverse(*/widgets/*.json): lam(fd: Fd, org: Str, widget: Str):

Now it's possible to typecheck the body (a lambda) before dealing with the
staged part of the program. The drawback is that we have to arrange things
positionally. An evaluation of the staged program will perform an arity
check to make sure that the number of arguments in the lambda are correct.

I think the second formulation of this is more reasonable. No tooling
could make sense of the identifiers that magically come into scope in the
first form. There are several riffs on this that are useful:

* If the lambda does not have a argument of type file descriptor, don't
  open the file.
* If the lambda does not have string arguments, that's fine. They might
  not need to be available in the body.
* Support state (an accumulator) or monoidal output.

All of these require that the staging system be able to examine the types
of the lambda arguments. This suggests that the staging system has access
to something like GHC's `Typeable` machinery.
